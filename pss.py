import os
import re
import json
import inspect
import argparse
import colorama
import threading
import mimetypes
import tornado.web
import tornado.ioloop
import netifaces as ni
import logging as logger
from pathlib import Path
from colorama import Fore
from prompt_toolkit.styles import Style
from prompt_toolkit import PromptSession
from prompt_toolkit.history import FileHistory
from prompt_toolkit.completion import NestedCompleter
from prompt_toolkit.auto_suggest import AutoSuggestFromHistory

import transformers


logger.basicConfig(
    format="%(asctime)s.%(msecs)03d %(levelname)s: %(message)s",
    level=logger.INFO,
    datefmt="%H:%M:%S"
)

CONFIG_DIR = Path("./configs/")

PLACEHOLDER_L = "<<"
PLACEHOLDER_R = ">>"
PLACEHOLDER_REGEX = re.compile(rf"{PLACEHOLDER_L}[A-Z]+{PLACEHOLDER_R}")
PLACEHOLDER_SHELL = f"{PLACEHOLDER_L}SHELL{PLACEHOLDER_R}"

IP_REGEX = re.compile(r"^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])$")


class PayloadManagerConfig():
    def __init__(self):
        self.cvars = {}
        self.stagers = []
        self.shells = []
        self.transformers = {}
        self.stager_folder = Path("./stagers/")
        self.serve_folder = None


class PayloadManager():
    def __new__(cls):
        if not hasattr(cls, "instance"):
            cls.instance = super(PayloadManager, cls).__new__(cls)
            cls.instance.cfg = PayloadManagerConfig()
        return cls.instance

    @property
    def shell_count(self) -> int:
        return len(self.cfg.shells)

    @property
    def stager_count(self) -> int:
        return len(self.cfg.stagers)

    @property
    def transformer_count(self) -> int:
        return len(self.cfg.transformers)

    def transformer_register(self, cls, enabled=False):
        self.cfg.transformers[cls.__name__] = {
            "transformer": cls(),
            "enabled": enabled
        }

    def get_cvar(self, name: str):
        name = name.upper()
        return self.cfg.cvars[name] if name in self.cfg.cvars else None

    def set_cvar(self, name: str, value):
        self.cfg.cvars[name.upper()] = value

    def load_stagers(self, folder):
        self.cfg.stager_folder = folder
        self.cfg.stagers = []

        for stager in [self.stager_process_path(x.relative_to(folder)) for x in get_all_files(folder)]:
            if self.stager_validate(stager):
                self.cfg.stagers.append(stager)
            else:
                logger.warning(f"Invalid stager \"{stager}\", missing placeholder: \"{PLACEHOLDER_SHELL}\"")

    def stager_process_path(self, stager_path: Path):
        return str(stager_path).replace("\\", "/").replace("//", "/").lower()

    def stager_validate(self, stager: str) -> bool:
        return self.stager_get_path(stager) is not None

    def stager_exists(self, stager: str) -> bool:
        if stager.startswith("/"):
            stager = stager[1:]
        return stager.lower() in self.cfg.stagers

    def stager_get_path(self, stager: str) -> Path or None:
        if stager.startswith("/"):
            stager = stager[1:]

        p = Path(self.cfg.stager_folder, stager)
        return p if p.exists() else None

    def stager_get_content(self, stager: str) -> str or None:
        stager_path = self.stager_get_path(stager)

        if stager_path:
            with open(stager_path) as stager_file:
                return stager_file.read()

        return None

    def load_shells(self, shells_json):
        self.cfg.shells = json.loads(shells_json)

    def shell_exists(self, shell: str) -> bool:
        return (shell.lower() in self.cfg.shells) if shell else False

    def shell_get_payload(self, shell: str) -> str or None:
        if self.shell_exists(shell):
            return self.cfg.shells[shell]["payload"]
        return None

    def tranformer_switch(self, transformer, status=None):
        if transformer in self.cfg.transformers:
            if status is None:
                self.cfg.transformers[transformer]["enabled"] = not self.cfg.transformers[transformer]["enabled"]
            else:
                self.cfg.transformers[transformer]["enabled"] = status

            if self.cfg.transformers[transformer]["enabled"]:
                logger.info(f"{transformer} {Fore.LIGHTGREEN_EX}enabled{Fore.RESET}")
            else:
                logger.info(f"{transformer} {Fore.LIGHTRED_EX}disabled{Fore.RESET}")
        else:
            logger.warning(f"Tranformer named \"{transformer}\" does not exist")

    def get_cvars_str(self, s: str):
        for cvar in PLACEHOLDER_REGEX.findall(s):
            yield cvar.replace(PLACEHOLDER_L, "").replace(PLACEHOLDER_R, "").upper()

    def get_cvars_shell(self, shell: str):
        shell_payload = self.shell_get_payload(shell)

        if shell_payload:
            for cvar in self.get_cvars_str(shell_payload):
                yield cvar

    def get_cvars(self, stager: str, shell: str = None):
        stager_path = self.stager_get_path(stager)

        if stager_path:
            with open(self.stager_get_path(stager)) as stager_file:
                for cvar in self.get_cvars_str(stager_file.read()):
                    yield cvar

            for cvar in self.get_cvars_shell(shell):
                yield cvar

    def insert_cvar(self, cvar, payload):
        val = self.get_cvar(cvar)

        if val:
            if not isinstance(val, str):
                val = str(val)

            logger.debug(f"CVAR {cvar} -> \"{val}\"")
            payload = payload.replace(f"{PLACEHOLDER_L}{cvar}{PLACEHOLDER_R}", val)
        else:
            logger.warning(f"Missing CVAR for shell: \"{cvar}\"")

        return payload

    def build_payload(self, stager: str, user_agent: str = None) -> str or None:
        shell = ""
        stager_path = self.stager_get_path(stager)

        if stager_path:
            stager_content = self.stager_get_content(stager)

            # insert shell and apply transformers
            shell_inserted = False

            if PLACEHOLDER_SHELL in stager_content:
                shell = self.get_cvar("SHELL")
                shell_payload = self.shell_get_payload(shell)

                if not shell_payload:
                    logger.warning("Stager requested a shell but none was given!")

                    try:
                        possible_os = user_agent.split("(")[1].split(" ")[0].lower()
                        logger.warning(f"OS detected by user-agent: {Fore.LIGHTYELLOW_EX}{possible_os}{Fore.RESET}")

                        # try to auto select a suiteable shell
                        if possible_os == "windows":
                            shell = "powershell_simple"
                        elif possible_os == "linux":
                            shell = "bash_simple"
                        else:
                            shell = ""

                        if not shell == "":
                            shell_payload = self.shell_get_payload(shell)

                            if shell_payload:
                                logger.warning(f"Auto-selected shell: {Fore.LIGHTYELLOW_EX}{shell}{Fore.RESET}")
                            else:
                                logger.warning(f"No suiteable shell found")

                    except:
                        logger.warning("Failed to auto-select a shell by user-agent")

                if shell_payload:
                    # insert all the shell cvars, because they might become unreadable during transformation
                    for cvar in self.get_cvars_str(shell_payload):
                        shell_payload = self.insert_cvar(cvar, shell_payload)

                    # apply the transformers on shell
                    for transformer in self.cfg.transformers.keys():
                        t = self.cfg.transformers[transformer]

                        if t["enabled"]:
                            tr = t["transformer"]
                            stager_content = tr.trim_chars(stager_content, PLACEHOLDER_SHELL)
                            shell_payload = tr.transform(shell_payload)

                    logger.debug(f"SHELL -> {shell}")
                    stager_content = stager_content.replace(PLACEHOLDER_SHELL, shell_payload)
                    shell_inserted = True

            # insert all the remaining cvars
            for cvar in self.get_cvars(stager, shell):
                if cvar == "SHELL" and shell_inserted:
                    continue

                stager_content = self.insert_cvar(cvar, stager_content)

            return stager_content
        return None


class PssHttpHandler(tornado.web.RequestHandler):
    def get(self):
        pm = PayloadManager()
        p = pm.build_payload(self.request.uri, self.request.headers.get("User-Agent", None))

        if p:
            self.set_status(200)
            self.finish(p)

        elif pm.cfg.serve_folder:
            filepath = self.request.uri

            if filepath.startswith("/"):
                filepath = filepath[1:]

            filepath = Path(pm.cfg.serve_folder, filepath)

            if filepath.exists() and filepath.is_file():
                self.set_status(200)

                try:
                    self.set_header("Content-Type", mimetypes.guess_type(filepath)[0])
                except:
                    self.set_header("Content-Type", "application/octet-stream")

                self.set_header("Content-Disposition", f"attachment; filename={filepath.name}")

                with open(filepath, "rb") as f:
                    self.write(f.read())

                self.finish()
            else:
                self.set_status(404)
                self.finish("404 File Not Found")
        else:
            self.set_status(404)
            self.finish("404 Not Found")


def get_all_files(path: str or Path):
    if not isinstance(path, Path):
        path = Path(path)

    if path.exists():
        for currentpath, _, files in os.walk(path):
            for file in files:
                yield Path(currentpath, file)


def change_serve_folder(folder):
    if folder.exists():
        logger.info(f"Serving folder changed to \"{Fore.LIGHTYELLOW_EX}{folder.absolute()}{Fore.RESET}\"")
        pm.cfg.serve_folder = folder
    else:
        logger.warning(f"Folder \"{Fore.LIGHTYELLOW_EX}{folder.absolute()}{Fore.RESET}\" does not exist")


def change_cvar(pm, cvar, val):
    if cvar == "LHOST" and not IP_REGEX.search(val):
        logger.info(f"\"{val}\" is no valid IPv4, treating it as a NIC")

        try:
            ip = ni.ifaddresses(val)[ni.AF_INET][0]["addr"]
            logger.info(f"NIC \"{val}\" has IPv4 \"{Fore.LIGHTYELLOW_EX}{ip}{Fore.RESET}\"")
            val = ip
        except:
            logger.warning(f"Failed to lookup IPv4 for NIC \"{Fore.LIGHTYELLOW_EX}{val}{Fore.RESET}\"")

    logger.info(f"{cvar} set to \"{Fore.LIGHTYELLOW_EX}{val}{Fore.RESET}\"")
    pm.set_cvar(cvar, val)


# runs the tornado server on a thread sot he cli doesn't blocks it
def start_http_server(address: str, port: int):
    address_port = f"{address}:{port}"
    logger.info(f"Starting HTTP server on {Fore.LIGHTYELLOW_EX}{address_port}{Fore.RESET}")

    ioloop = tornado.ioloop.IOLoop()
    app = tornado.web.Application([(r".*", PssHttpHandler)])
    app.listen(port, address=address)
    ioloop.start()


def validate_cmd_len(cmd_arr, expected_len, fail_msg=None):
    if len(cmd_arr) >= expected_len:
        return True
    elif fail_msg:
        logger.warning(fail_msg)
    return False


def split_cmd_args(arr):
    return arr[0].lower(), arr[1:]


def build_config_path(name: str) -> Path:
    if not CONFIG_DIR.exists():
        os.makedirs(CONFIG_DIR)

    # path may start with a "/", this is intended,
    # beware of file overwriting
    config_path = Path(CONFIG_DIR, name)

    if not config_path.parent.exists():
        os.makedirs(config_path)

    return config_path


def save_config(name, pm):
    config_path = build_config_path(name)
    logger.info(f"Saved config \"{Fore.LIGHTYELLOW_EX}{name}{Fore.RESET}\"")

    try:
        with open(config_path, "w+") as cfg_file:
            cfg_file.write(json.dumps(PayloadManager().cfg.__dict__))
    except Exception as ex:
        logger.warning(f"Failed to save file \"{Fore.LIGHTRED_EX}{name}{Fore.RESET}\": {ex}")


def load_config(name, pm):
    config_path = build_config_path(name)

    if config_path.exists():
        try:
            with open(config_path, "w+") as cfg_file:
                PayloadManager().cfg = json.loads(cfg_file.read())

            logger.info(f"Loaded config \"{Fore.LIGHTYELLOW_EX}{name}{Fore.RESET}\"")
        except Exception as ex:
            logger.warning(f"Failed to load file \"{Fore.LIGHTRED_EX}{name}{Fore.RESET}\": {ex}")
    else:
        logger.warning(f"Config file \"{Fore.LIGHTRED_EX}{name}{Fore.RESET}\" does not exist")


def print_toolbar():
    pm = PayloadManager()
    bottom_str = "Shell: " + str(pm.get_cvar("SHELL")) 
    bottom_str += " | LHOST: " + str(pm.get_cvar("LHOST"))
    bottom_str += " | LPORT: " + str(pm.get_cvar("LPORT"))

    if pm.cfg.serve_folder:
        bottom_str += f" | Serving: \"{pm.cfg.serve_folder.absolute()}\""

    return bottom_str


def print_cmd_unknown(cmd):
    if cmd and len(cmd) > 0:
        logger.warning("Unknown command, type \"?\" or \"help\"")


def print_help():
    print(f">> {Fore.LIGHTYELLOW_EX}Basic{Fore.RESET}")
    print("- exit                  : Shutdown server and exit")
    print("- save {NAME}           : Save current options and shell selection. No name to save as default.")
    print("- load {NAME}           : Load saved options and shell selection No name to load default.")
    print("- set {NAME} {VALUE} (s): Set the options value")
    print("- serve {VALUE}      (x): Set the serving folder")
    print("- ncl                   : Generate netcat listener command")
    print("- msfl                  : Generate metasploit multi/handler listener command")

    print(f"\n>> {Fore.LIGHTYELLOW_EX}Shells{Fore.RESET} (sh, shells)")
    print("- list          (l): List all loaded shells")
    print("- select {NAME} (s): Select a shell payload")
    print("- options       (o): Show options for the selected shell")

    print(f"\n>> {Fore.LIGHTYELLOW_EX}Stagers{Fore.RESET} (st, stagers)")
    print("- list         (l): List all loaded stagers")
    print("- print {NAME} (p): Print stager")
    print("- build {NAME} (b): Print stager with shell")

    print(f"\n>> {Fore.LIGHTYELLOW_EX}Transformers{Fore.RESET} (t, transformers)")
    print("- list           (l): List all loaded transformers")
    print("- disableall     (x): Disable all transformers")
    print("- enable {NAME}  (e): Enable a transformer")
    print("- disable {NAME} (d): Disable a transformer")


if __name__ == "__main__":
    colorama.init()

    parser = argparse.ArgumentParser()
    parser.add_argument(
        '-H', '--http-host',
        default='0.0.0.0',
        dest='http_host',
        help='Listen address for the HTTP server',
        type=str
    )
    parser.add_argument(
        '-P', '--http-port',
        default='80',
        dest='http_port',
        help='Listen port for the HTTP server',
        type=int
    )
    parser.add_argument(
        '-S', '--serve',
        default=None,
        dest='serve_folder',
        help='Serve folder for the HTTP server',
        type=str
    )
    parser.add_argument(
        '--shells-file',
        default='./shells.json',
        dest='shells_file',
        help='JSON file containing shell payloads',
        type=str
    )
    parser.add_argument(
        '--stagers-folder',
        default='./stagers/',
        dest='stagers_folder',
        help='Folder containing stager files',
        type=str
    )
    parser.add_argument(
        '--lhost',
        default='',
        dest='lhost',
        help='Default LHOST value',
        type=str
    )
    parser.add_argument(
        '--lport',
        default='4711',
        dest='lport',
        help='Default LPORT value',
        type=str
    )
    args = parser.parse_args()

    print(f" ▄▄▄▄▄▄ ▄▄▄▄▄▄▄ ▄▄▄▄▄▄▄ ")
    print(f"█   ▄  █  ▄▄▄▄▄█  ▄▄▄▄▄█")
    print(f"█  █▄█ █ █▄▄▄▄▄█ █▄▄▄▄▄ ")
    print(f"█   ▄▄▄█▄▄▄▄▄  █▄▄▄▄▄  █")
    print(f"█  █    ▄▄▄▄▄█ █▄▄▄▄▄█ █")
    print(f"█▄▄█   █▄▄▄▄▄▄▄█▄▄▄▄▄▄▄█")
    print(f">> {Fore.LIGHTYELLOW_EX}Pentest Server Suite{Fore.RESET}")
    print(f"   https://github.com/Jnnshschl/PentestServerSuite\n")

    pm = PayloadManager()
    pm.cfg.serve_folder = Path(args.serve_folder)

    if len(args.lhost) > 0:
        pm.set_cvar("LHOST", args.lhost)
    pm.set_cvar("LPORT", args.lport)

    # load all shells
    if Path(args.shells_file).exists():
        with open(args.shells_file) as shells_file:
            pm.load_shells(shells_file.read())

        logger.info(f"Loaded {Fore.LIGHTYELLOW_EX}{pm.shell_count}{Fore.RESET} shells")
    else:
        logger.error(f"Shells file missing: \"{args.shells_file}\"")

    shells_set = {}

    for shell in pm.cfg.shells:
        shells_set[shell] = None

    # load all stagers
    if Path(args.stagers_folder).exists():
        pm.load_stagers(args.stagers_folder)
        logger.info(f"Loaded {Fore.LIGHTYELLOW_EX}{pm.stager_count}{Fore.RESET} stagers")
    else:
        logger.error(f"Stagers folder missing: \"{args.stagers_folder}\"")

    stagers_set = {}

    for stager in pm.cfg.stagers:
        stagers_set[stager] = None

    # load all tranformers
    default_transformers = inspect.getmembers(
        transformers,
        lambda o: inspect.isclass(o) and issubclass(o, transformers.ITransformer)
    )

    transformers_set = {}

    for transformer in default_transformers:
        if transformer[0] != "ITransformer":
            pm.transformer_register(transformer[1])
            transformers_set[transformer[0]] = None

    logger.info(f"Loaded {Fore.LIGHTYELLOW_EX}{pm.transformer_count}{Fore.RESET} tranformers")

    # start tornado webserver in background
    tornado_thread = threading.Thread(target=start_http_server, args=[args.http_host, args.http_port], daemon=True)
    tornado_thread.start()

    # setup prompt
    cli_session = PromptSession(
        # history=FileHistory("~/.psshistory"),
        auto_suggest=AutoSuggestFromHistory(),
        bottom_toolbar=print_toolbar,
        style=Style.from_dict({"pss": "ansibrightyellow"}),
        completer=NestedCompleter.from_nested_dict({
            "exit": None,
            "save": None,
            "load": None,
            "set": {
                "LHOST": None,
                "LPORT": None,
            },
            "serve": None,
            "ncl": None,
            "msfl": None,
            "shell": {
                "list": None,
                "set": shells_set,
                "options": None,
            },
            "stager": {
                "list": None,
                "print": stagers_set,
                "build": stagers_set,
            },
            "transformer": {
                "list": None,
                "disableall": None,
                "enable": transformers_set,
                "disable": transformers_set,
            }
        }),
        message=[
            ("class:pss", "pss"),
            ("", "> "),
        ]
    )

    # enter cmd loop
    while 1:
        input_arr = cli_session.prompt().strip().split(" ")
        cmd, args = split_cmd_args(input_arr)

        if cmd == "?" or cmd == "help":
            print_help()

        elif cmd == "exit":
            break

        elif cmd == "save":
            save_config(args[0] if len(args) > 0 else "default", pm)

        elif cmd == "load":
            load_config(args[0] if len(args) > 0 else "default", pm)

        elif cmd == "s" or cmd == "set":
            if validate_cmd_len(input_arr, 2, "Missing arguments: \"cvar name\", \"value\""):
                if validate_cmd_len(input_arr, 3, "Missing arguments: \"value\""):
                    change_cvar(pm, input_arr[1].upper(), " ".join(input_arr[2:]))

        elif cmd == "x" or cmd == "serve":
            if validate_cmd_len(input_arr, 2, "Missing arguments: \"folder\""):
                change_serve_folder(Path(" ".join(input_arr[1:])))

        elif cmd == "ncl":
            lport = pm.get_cvar("LPORT")
            print(f"nc -lvpn {lport}")

        elif cmd == "msfl":
            lhost = pm.get_cvar("LHOST")
            lport = pm.get_cvar("LPORT")
            print(f"msfconsole -q -x \"use multi/handler; set LHOST {lhost}; set LPORT {lport}; run\"")

        elif cmd == "sh" or cmd == "shell" or cmd == "shells":
            # SHELL sub-commands
            if validate_cmd_len(input_arr, 2, f"Missing arguments: \"sub-command\""):
                sub_cmd, sub_args = split_cmd_args(args)

                if sub_cmd == "l" or sub_cmd == "list":
                    for shell in pm.cfg.shells:
                        print(shell)

                elif sub_cmd == "s" or sub_cmd == "set" or sub_cmd == "select":
                    shell = sub_args[0].lower()

                    if pm.shell_exists(shell):
                        logger.info(f"Shell set to \"{Fore.LIGHTYELLOW_EX}{shell}{Fore.RESET}\"")
                        pm.set_cvar("SHELL", shell)
                    else:
                        logger.warning(f"No shell found with name \"{Fore.LIGHTRED_EX}{shell}{Fore.RESET}\". If you want to directly inject something, set the SHELL option manually using \"set SHELL ...\"")

                elif sub_cmd == "o" or sub_cmd == "options":
                    shell = pm.get_cvar("SHELL")
                    logger.info(f"Selected shell \"{Fore.LIGHTYELLOW_EX}{shell}{Fore.RESET}\"")

                    if shell:
                        for cvar in pm.get_cvars_shell(shell):
                            val = pm.get_cvar(cvar)

                            if val:
                                logger.info(f"{cvar} = \"{Fore.LIGHTYELLOW_EX}{val}{Fore.RESET}\"")
                            else:
                                logger.info(f"{cvar} = {Fore.LIGHTRED_EX}Not set{Fore.RESET}")

                else:
                    print_cmd_unknown(sub_cmd)

        elif cmd == "st" or cmd == "stager" or cmd == "stagers":
            # STAGER sub-commands
            if validate_cmd_len(input_arr, 2, f"Missing arguments: \"sub-command\""):
                sub_cmd, sub_args = split_cmd_args(args)

                if sub_cmd == "l" or sub_cmd == "list":
                    for stager in pm.cfg.stagers:
                        print(stager)

                elif sub_cmd == "p" or sub_cmd == "print":
                    print(pm.stager_get_content(sub_args[0].lower()))

                elif sub_cmd == "b" or sub_cmd == "build":
                    print(pm.build_payload(sub_args[0].lower()))

                else:
                    print_cmd_unknown(sub_cmd)

        elif cmd == "t" or cmd == "transformer" or cmd == "transformers":
            # TRANFORMER sub-commands
            if validate_cmd_len(input_arr, 2, f"Missing arguments: \"sub-command\""):
                sub_cmd, sub_args = split_cmd_args(args)

                if sub_cmd == "l" or sub_cmd == "list":
                    for transformer in pm.cfg.transformers.keys():
                        is_enabled = pm.cfg.transformers[transformer]["enabled"]
                        color = Fore.LIGHTGREEN_EX if is_enabled else Fore.LIGHTRED_EX
                        print(f"{transformer}: {color}{is_enabled}{Fore.RESET}")

                elif sub_cmd == "x" or sub_cmd == "disableall":
                    for transformer in pm.cfg.transformers.keys():
                        is_enabled = pm.cfg.transformers[transformer]["enabled"]

                        if is_enabled:
                            pm.cfg.transformers[transformer]["enabled"] = False
                            logger.info(f"{transformer} {Fore.LIGHTRED_EX}disabled{Fore.RESET}")

                elif sub_cmd == "e" or sub_cmd == "+" or sub_cmd == "enable":
                    pm.tranformer_switch(sub_args[0], True)

                elif sub_cmd == "d" or sub_cmd == "-" or sub_cmd == "disable":
                    pm.tranformer_switch(sub_args[0], False)

                elif args[0] in pm.cfg.transformers:
                    pm.tranformer_switch(args[0])

                else:
                    print_cmd_unknown(sub_cmd)

        else:
            print_cmd_unknown(cmd)

    colorama.deinit()
