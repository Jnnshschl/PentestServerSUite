import argparse
import inspect
import logging as logger
import os
import re
from pathlib import Path

import colorama
import netifaces as ni
import pyperclip
from colorama import Fore
from prompt_toolkit import PromptSession
from prompt_toolkit.auto_suggest import AutoSuggestFromHistory
from prompt_toolkit.completion import NestedCompleter
from prompt_toolkit.formatted_text import HTML
from prompt_toolkit.history import FileHistory
from prompt_toolkit.styles import Style
from prompt_toolkit.shortcuts import CompleteStyle

import pssutil.transformers
from pssutil.payloadmanager import PayloadManager

from pssmods.psshttp import PssHttpServer
from pssmods.psssmb import PssSmbServer
from pssmods.pssftp import PssFtpServer


logger.basicConfig(
    format="%(asctime)s.%(msecs)03d %(levelname)s: %(message)s",
    level=logger.INFO,
    datefmt="%H:%M:%S",
)

CONFIG_DIR = Path("./configs/")

IP_REGEX = re.compile(
    r"^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])$"
)


def change_serve_folder(
    folder: Path, smb_server: PssSmbServer, ftp_server: PssFtpServer
):
    if folder.exists():
        logger.info(
            f'Serving folder changed to "{Fore.LIGHTYELLOW_EX}{folder.absolute()}{Fore.RESET}"'
        )

        prev_logging_level = logger.getLogger().level
        logger.getLogger().setLevel(logger.WARNING)

        # http serve folder is set via config
        pm.cfg.serve_folder = folder

        if pm.cfg.uploads_use_serve_folder:
            pm.cfg.uploads_folder = Path(pm.cfg.serve_folder, "uploads")

        if smb_server:
            smb_server.set_folder(folder)

        if ftp_server:
            ftp_server.set_folder(folder)

        logger.getLogger().setLevel(prev_logging_level)
    else:
        logger.warning(
            f'Folder "{Fore.LIGHTYELLOW_EX}{folder.absolute()}{Fore.RESET}" does not exist'
        )


def change_cvar(pm, cvar, val):
    # try to resolve network interface name to ip address
    if cvar == "LHOST" and not IP_REGEX.search(val):
        try:
            val = ni.ifaddresses(val)[ni.AF_INET][0]["addr"]
        except:
            logger.warning(
                f'Failed to lookup IPv4 for NIC "{Fore.LIGHTYELLOW_EX}{val}{Fore.RESET}"'
            )

    logger.info(f'{cvar} set to "{Fore.LIGHTYELLOW_EX}{val}{Fore.RESET}"')
    pm.set_cvar(cvar, val)


def validate_cmd_len(cmd_arr, expected_len, fail_msg=None):
    if len(cmd_arr) >= expected_len:
        return True
    elif fail_msg:
        logger.warning(fail_msg)
    return False


def split_cmd_args(arr):
    return arr[0].lower(), arr[1:]


def build_config_path(name: str) -> Path:
    if not CONFIG_DIR.exists():
        os.makedirs(CONFIG_DIR)

    # path may start with a "/", this is intended,
    # beware of file overwriting
    config_path = Path(CONFIG_DIR, name)

    if not config_path.parent.exists():
        os.makedirs(config_path)

    return config_path


def handle_command(remaining_args: list, s: str):
    if len(remaining_args) > 0:
        first_arg_lower = remaining_args[0].lower()
        if first_arg_lower in ["c", "copy"]:
            print(s)

            try:
                pyperclip.copy(s)
            except Exception as ex:
                logger.error(f"Failed to copy to clipboard: {str(ex)}")

        elif first_arg_lower in ["x", "execute"]:
            try:
                os.system(s)
            except Exception as ex:
                logger.error(f'Failed to execute "{s}": {str(ex)}')

        elif first_arg_lower in ["t", "tmux"]:
            try:
                os.system(f"tmux new '{s}'")
            except Exception as ex:
                logger.error(f'Failed to start tmux "{s}": {str(ex)}')


def print_toolbar():
    pm = PayloadManager()
    bottom_str = (
        'SHELL: <style bg="ansiyellow">' + str(pm.get_cvar("SHELL")) + "</style>"
    )
    bottom_str += (
        ' | SHELLBIN: <style bg="ansiyellow">'
        + str(pm.get_cvar("SHELLBIN"))
        + "</style>"
    )
    bottom_str += (
        ' | LHOST: <style bg="ansiyellow">' + str(pm.get_cvar("LHOST")) + "</style>"
    )
    bottom_str += (
        ' | LPORT: <style bg="ansiyellow">' + str(pm.get_cvar("LPORT")) + "</style>"
    )

    if pm.cfg.serve_folder:
        bottom_str += f' | Serving: "<style bg="ansiyellow">{pm.cfg.serve_folder.absolute()}</style>"'

    return HTML(bottom_str)


def print_cmd_unknown(cmd):
    if cmd and len(cmd) > 0:
        logger.warning(
            'Unknown command, type "?" or "help", "!" to execute os commands'
        )


def print_help():
    print(f">> {Fore.LIGHTYELLOW_EX}Basic{Fore.RESET}")
    print("- exit                      : Shutdown server and exit.")
    print(
        "- save {NAME}               : Save current options and shell selection. No name to save as default."
    )
    print(
        "- load {NAME}               : Load saved options and shell selection. No name to load default."
    )
    print("- set {NAME} {VALUE} (s)    : Set the options value.")
    print("- serve {VALUE}      (x)    : Set the serving folder.")
    print("- http (copy)               : Print/copy the http server address.")
    print("- smb (copy)                : Print/copy the smb server address.")
    print("- ftp (copy)                : Print/copy the ftp server address.")
    print(
        "- pty (copy, execute, tmux)  : Generate/copy python pty shell upgrade command."
    )
    print("- nc (copy, execute, tmux)   : Generate/copy netcat listener command.")
    print("- ncat (copy, execute, tmux)  : Generate/copy ncat listener command.")
    print(
        "- msf (copy, execute, tmux)  : Generate/copy metasploit multi/handler listener command."
    )

    print(f"\n>> {Fore.LIGHTYELLOW_EX}Shells{Fore.RESET} (sh, shells)")
    print("- list          (l): List all loaded shells.")
    print("- select {NAME} (s): Select a shell payload.")
    print("- options       (o): Show options for the selected shell.")

    print(f"\n>> {Fore.LIGHTYELLOW_EX}Launchers{Fore.RESET} (l, launchers)")
    print("- generate {LAUNCHER} (copy) : Generate/copy a launcher command.")
    print("- list                (l)    : List all loaded launchers.")

    print(f"\n>> {Fore.LIGHTYELLOW_EX}Stagers{Fore.RESET} (st, stagers)")
    print("- list         (l): List all loaded stagers.")
    print("- print {NAME} (p): Print stager.")
    print("- build {NAME} (b): Print stager with shell.")

    print(f"\n>> {Fore.LIGHTYELLOW_EX}Transformers{Fore.RESET} (t, transformers)")
    print("- list           (l): List all loaded transformers.")
    print("- disableall     (x): Disable all transformers.")
    print("- enable {NAME}  (e): Enable a transformer.")
    print("- disable {NAME} (d): Disable a transformer.")


if __name__ == "__main__":
    colorama.init()

    parser = argparse.ArgumentParser()
    parser.add_argument(
        "--http-host",
        default="0.0.0.0",
        dest="http_host",
        help="Listen address for the HTTP server",
        type=str,
    )
    parser.add_argument(
        "--http-port",
        default="80",
        dest="http_port",
        help="Listen port for the HTTP server",
        type=int,
    )
    parser.add_argument(
        "--smb-host",
        default="0.0.0.0",
        dest="smb_host",
        help="Listen address for the SMB server",
        type=str,
    )
    parser.add_argument(
        "--smb-port",
        default="445",
        dest="smb_port",
        help="Listen port for the SMB server",
        type=int,
    )
    parser.add_argument(
        "--ftp-host",
        default="0.0.0.0",
        dest="ftp_host",
        help="Listen address for the FTP server",
        type=str,
    )
    parser.add_argument(
        "--ftp-port",
        default="21",
        dest="ftp_port",
        help="Listen port for the FTP server",
        type=int,
    )
    parser.add_argument(
        "-S",
        "--serve",
        default=None,
        dest="serve_folder",
        help="Serve folder for the HTTP server",
        type=str,
    )
    parser.add_argument(
        "--shells-file",
        default="./shells.json",
        dest="shells_file",
        help="JSON file containing shells",
        type=str,
    )
    parser.add_argument(
        "--launchers-file",
        default="./launchers.json",
        dest="launchers_file",
        help="JSON file containing launchers",
        type=str,
    )
    parser.add_argument(
        "--stagers-folder",
        default="./stagers/",
        dest="stagers_folder",
        help="Folder containing stager files",
        type=str,
    )
    parser.add_argument(
        "--lhost", default="", dest="lhost", help="Default LHOST value", type=str
    )
    parser.add_argument(
        "--lport", default="4711", dest="lport", help="Default LPORT value", type=str
    )
    parser.add_argument(
        "--shellbin",
        default="/bin/bash",
        dest="shellbin",
        help="Default shell binary to use",
        type=str,
    )
    parser.add_argument(
        "--no-http",
        default=False,
        dest="no_http",
        help="Disable HTTP server",
        action="store_true",
    )
    parser.add_argument(
        "--no-smb",
        default=False,
        dest="no_smb",
        help="Disable SMB server",
        action="store_true",
    )
    parser.add_argument(
        "--no-smb2",
        default=False,
        dest="no_smb2",
        help="Disable SMB2 support",
        action="store_true",
    )
    parser.add_argument(
        "--no-ftp",
        default=False,
        dest="no_ftp",
        help="Disable FTP server",
        action="store_true",
    )
    parser.add_argument(
        "--no-uploads",
        default=True,
        dest="accept_uploads",
        help="Disable HTTP file upload support",
        action="store_false",
    )
    parser.add_argument(
        "-U",
        "--upload-folder",
        default=None,
        dest="uploads_folder",
        help="Folder to store files uploaded via HTTP POST",
        type=str,
    )
    parser.add_argument(
        "--no-history",
        default=False,
        dest="no_history",
        help='Disable history saving in file "~/.psshistory"',
        action="store_true",
    )
    args = parser.parse_args()

    print(f">> {Fore.LIGHTYELLOW_EX}Pentest Server Suite{Fore.RESET}")
    print("   https://github.com/Jnnshschl/PentestServerSuite\n")

    pm = PayloadManager()

    # load all shells
    if Path(args.shells_file).exists():
        with open(args.shells_file) as shells_file:
            pm.load_shells(shells_file.read())

        logger.info(f"Loaded {Fore.LIGHTYELLOW_EX}{pm.shell_count}{Fore.RESET} Shells")
    else:
        logger.error(f'Shells file missing: "{args.shells_file}"')

    shells_set = {}

    for shell in pm.cfg.shells:
        shells_set[shell] = None

    # load all stagers
    if Path(args.stagers_folder).exists():
        pm.load_stagers(args.stagers_folder)
        logger.info(
            f"Loaded {Fore.LIGHTYELLOW_EX}{pm.stager_count}{Fore.RESET} Stagers"
        )
    else:
        logger.error(f'Stagers folder missing: "{args.stagers_folder}"')

    stagers_set = {}

    for stager in pm.cfg.stagers:
        stagers_set[stager] = None

    # load all launchers
    if Path(args.launchers_file).exists():
        with open(args.launchers_file) as launchers_file:
            pm.load_launchers(launchers_file.read())

        logger.info(
            f"Loaded {Fore.LIGHTYELLOW_EX}{pm.launcher_count}{Fore.RESET} Launchers"
        )
    else:
        logger.error(f'Launchers file missing: "{args.launchers_file}"')

    launchers_set = {}

    for launcher in pm.cfg.launchers:
        launchers_set[launcher] = stagers_set

    # load all tranformers
    default_transformers = inspect.getmembers(
        pssutil.transformers,
        lambda o: inspect.isclass(o)
        and issubclass(o, pssutil.transformers.ITransformer),
    )

    transformers_set = {}

    for transformer in default_transformers:
        if transformer[0] != "ITransformer":
            pm.transformer_register(transformer[1])
            transformers_set[transformer[0]] = None

    logger.info(
        f"Loaded {Fore.LIGHTYELLOW_EX}{pm.transformer_count}{Fore.RESET} Tranformers"
    )

    # set initial cvar values
    if args.lhost and len(args.lhost) > 0:
        change_cvar(pm, "LHOST", args.lhost)
    else:
        # try to select a default nic as LHOST
        for iface in ni.interfaces():
            if iface in ["tun0", "eth0"]:
                change_cvar(pm, "LHOST", iface)
                break

    change_cvar(pm, "LPORT", args.lport if args.lport else 4711)
    change_cvar(pm, "SHELLBIN", args.shellbin if args.shellbin else "/bin/bash")

    # start servers in background
    serve_folder = Path(args.serve_folder)

    http_server = (
        PssHttpServer(args.http_host, int(args.http_port), serve_folder)
        if not args.no_http
        else None
    )

    ftp_server = (
        PssFtpServer(args.ftp_host, int(args.ftp_port), serve_folder)
        if not args.no_ftp
        else None
    )

    smb_server = (
        PssSmbServer(args.smb_host, int(args.smb_port), serve_folder)
        if not args.no_smb
        else None
    )

    # change serving folder if supplied
    if args.serve_folder:
        change_serve_folder(serve_folder, smb_server, ftp_server)

    # set uploads folder to supplied value, otherwise place stuff in the serve folder
    pm.cfg.accept_uploads = args.accept_uploads

    if pm.cfg.accept_uploads:
        if args.uploads_folder:
            pm.cfg.uploads_folder = Path(args.uploads_folder)
        else:
            pm.cfg.uploads_folder = Path(pm.cfg.serve_folder, "uploads")
            pm.cfg.uploads_use_serve_folder = True

    # setup prompt
    shells_dict = {
        "list": None,
        "set": shells_set,
        "select": shells_set,
        "options": None,
    }

    launchers_dict = {
        "list": None,
        "generate": launchers_set,
    }

    stagers_dict = {
        "list": None,
        "print": stagers_set,
        "build": stagers_set,
    }

    transformers_dict = {
        "list": None,
        "disableall": None,
        "enable": transformers_set,
        "disable": transformers_set,
    }

    copy_dict = {"copy": None}

    netifaces_dict = {}

    for iface in ni.interfaces():
        netifaces_dict[iface] = None

    ports_dict = {
        "25": None,
        "80": None,
        "443": None,
        "1337": None,
        "4444": None,
        "4711": None,
    }

    cli_session = PromptSession(
        history=None
        if args.no_history
        else FileHistory(Path(os.path.expanduser("~"), ".psshistory")),
        auto_suggest=AutoSuggestFromHistory(),
        bottom_toolbar=print_toolbar,
        complete_style=CompleteStyle.READLINE_LIKE,
        style=Style.from_dict(
            {"pss": "ansibrightyellow", "bottom-toolbar": "#303030 bg:#dddddd"}
        ),
        completer=NestedCompleter.from_nested_dict(
            {
                "exit": None,
                "save": None,
                "load": None,
                "set": {
                    "LHOST": netifaces_dict,
                    "LPORT": ports_dict,
                },
                "serve": None,
                "http": copy_dict,
                "smb": copy_dict,
                "ncl": copy_dict,
                "msfl": copy_dict,
                "pty": copy_dict,
                "sh": shells_dict,
                "shell": shells_dict,
                "shells": shells_dict,
                "l": launchers_dict,
                "launcher": launchers_dict,
                "launchers": launchers_dict,
                "st": stagers_dict,
                "stager": stagers_dict,
                "stagers": stagers_dict,
                "t": transformers_dict,
                "transformer": transformers_dict,
                "transformers": transformers_dict,
            }
        ),
        message=[
            ("class:pss", "pss"),
            ("", "> "),
        ],
    )

    while 1:
        input_arr = cli_session.prompt().strip().split(" ")
        cmd, args = split_cmd_args(input_arr)

        if cmd in ["?", "help"]:
            print_help()

        elif cmd.startswith("!"):
            try:
                os_cmd = "".join(cmd[1:]) + " " + " ".join(args)

                try:
                    if len(os_cmd) == 0:
                        os_cmd = os.environ.get("SHELL", "bash")

                    os.system(os_cmd)
                except Exception as ex:
                    logger.warning(
                        f'Failed to execute: "{Fore.LIGHTRED_EX}{os_cmd}{Fore.RESET}": {ex}'
                    )
            except Exception as ex:
                logger.warning(f"Failed parse command: {ex}")

        elif cmd == "exit":
            break

        elif cmd == "save":
            pm.save_config(build_config_path(args[0] if len(args) > 0 else "default"))

        elif cmd == "load":
            pm.load_config(build_config_path(args[0] if len(args) > 0 else "default"))

        elif cmd in ["s", "set"]:
            if validate_cmd_len(
                input_arr, 2, 'Missing arguments: "cvar name", "value"'
            ):
                if validate_cmd_len(input_arr, 3, 'Missing arguments: "value"'):
                    change_cvar(pm, input_arr[1].upper(), " ".join(input_arr[2:]))

        elif cmd in ["x", "serve"]:
            if validate_cmd_len(input_arr, 2, 'Missing arguments: "folder"'):
                change_serve_folder(
                    Path(" ".join(input_arr[1:])), smb_server, ftp_server
                )

        elif cmd == "http":
            lhost = pm.get_cvar("LHOST")
            handle_command(args, f"http://{lhost}/")

        elif cmd == "smb":
            lhost = pm.get_cvar("LHOST")
            handle_command(args, f"\\\\{lhost}\\{smb_server.default_share}\\")

        elif cmd == "ftp":
            lhost = pm.get_cvar("LHOST")
            handle_command(args, f"anonymous@{lhost}")

        elif cmd in ["l", "launcher", "launchers"]:
            # LAUNCHER sub-commands
            if validate_cmd_len(input_arr, 2, 'Missing arguments: "sub-command"'):
                sub_cmd, sub_args = split_cmd_args(args)

                if sub_cmd in ["l", "list"]:
                    for launcher in pm.cfg.launchers:
                        print(launcher)

                elif sub_cmd in ["g", "generate"]:
                    if validate_cmd_len(input_arr, 3, 'Missing arguments: "launcher"'):
                        launcher, sub_sub_args = split_cmd_args(sub_args)

                        if validate_cmd_len(
                            input_arr,
                            4,
                            f'No stager sepcified, using "{Fore.LIGHTYELLOW_EX}pss/direct{Fore.RESET}" as default...',
                        ):
                            stager, sub_sub_args = split_cmd_args(sub_sub_args)
                        else:
                            stager = "pss/direct"

                        launcher_cmd = pm.launcher_generate(
                            launcher, stager, smb_server.default_share
                        )
                        handle_command(sub_sub_args, launcher_cmd)

                else:
                    print_cmd_unknown(sub_cmd)

        elif cmd == "nc":
            lport = pm.get_cvar("LPORT")
            handle_command(args, f"nc -lvnp {lport}")

        elif cmd == "ncat":
            lport = pm.get_cvar("LPORT")
            handle_command(args, f"ncat -lvnp {lport}")

        elif cmd == "msf":
            lhost = pm.get_cvar("LHOST")
            lport = pm.get_cvar("LPORT")
            handle_command(
                args,
                f'msfconsole -q -x "use multi/handler; set LHOST {lhost}; set LPORT {lport}; run"',
            )

        elif cmd == "pty":
            shellbin = pm.get_cvar("SHELLBIN")
            handle_command(args, f"python -c 'import pty; pty.spawn(\"{shellbin}\")'")

        elif cmd in ["sh", "shell", "shells"]:
            # SHELL sub-commands
            if validate_cmd_len(input_arr, 2, 'Missing arguments: "sub-command"'):
                sub_cmd, sub_args = split_cmd_args(args)

                if sub_cmd in ["l", "list"]:
                    for shell in pm.cfg.shells:
                        print(shell)

                elif sub_cmd in ["s", "set", "select"]:
                    shell = sub_args[0].lower()

                    if pm.shell_exists(shell):
                        logger.info(
                            f'Shell set to "{Fore.LIGHTYELLOW_EX}{shell}{Fore.RESET}"'
                        )
                        pm.set_cvar("SHELL", shell)
                    else:
                        logger.warning(
                            f'No shell found with name "{Fore.LIGHTRED_EX}{shell}{Fore.RESET}". If you want to directly inject something, set the SHELL option manually using "set SHELL ..."'
                        )

                elif sub_cmd in ["o", "options"]:
                    shell = pm.get_cvar("SHELL")
                    logger.info(
                        f'Selected shell "{Fore.LIGHTYELLOW_EX}{shell}{Fore.RESET}"'
                    )

                    if shell:
                        for cvar in pm.get_cvars_shell(shell):
                            val = pm.get_cvar(cvar)

                            if val:
                                logger.info(
                                    f'{cvar} = "{Fore.LIGHTYELLOW_EX}{val}{Fore.RESET}"'
                                )
                            else:
                                logger.info(
                                    f"{cvar} = {Fore.LIGHTRED_EX}Not set{Fore.RESET}"
                                )

                else:
                    print_cmd_unknown(sub_cmd)

        elif cmd in ["st", "stager", "stagers"]:
            # STAGER sub-commands
            if validate_cmd_len(input_arr, 2, 'Missing arguments: "sub-command"'):
                sub_cmd, sub_args = split_cmd_args(args)

                if sub_cmd in ["l", "list"]:
                    for stager in pm.cfg.stagers:
                        print(stager)

                elif sub_cmd in ["p", "print"]:
                    print(pm.stager_get_content(sub_args[0].lower()))

                elif sub_cmd in ["b", "build"]:
                    print(pm.build_payload(sub_args[0].lower()))

                else:
                    print_cmd_unknown(sub_cmd)

        elif cmd in ["t", "transformer", "transformers"]:
            # TRANFORMER sub-commands
            if validate_cmd_len(input_arr, 2, 'Missing arguments: "sub-command"'):
                sub_cmd, sub_args = split_cmd_args(args)

                if sub_cmd in ["l", "list"]:
                    for transformer in pm.cfg.transformers.keys():
                        is_enabled = pm.cfg.transformers[transformer]["enabled"]
                        color = Fore.LIGHTGREEN_EX if is_enabled else Fore.LIGHTRED_EX
                        print(f"{transformer}: {color}{is_enabled}{Fore.RESET}")

                elif sub_cmd in ["x", "disableall"]:
                    for transformer in pm.cfg.transformers.keys():
                        is_enabled = pm.cfg.transformers[transformer]["enabled"]

                        if is_enabled:
                            pm.cfg.transformers[transformer]["enabled"] = False
                            logger.info(
                                f"{transformer} {Fore.LIGHTRED_EX}disabled{Fore.RESET}"
                            )

                elif sub_cmd in ["e", "+", "enable"]:
                    pm.tranformer_switch(sub_args[0], True)

                elif sub_cmd in ["d", "-", "disable"]:
                    pm.tranformer_switch(sub_args[0], False)

                elif args[0] in pm.cfg.transformers:
                    pm.tranformer_switch(args[0])

                else:
                    print_cmd_unknown(sub_cmd)

        else:
            print_cmd_unknown(cmd)

    colorama.deinit()
