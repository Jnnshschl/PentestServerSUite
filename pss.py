import argparse
import inspect
import json
import logging as logger
import mimetypes
import os
import re
import threading
from pathlib import Path

import colorama
import netifaces as ni
import pyperclip
import tornado.ioloop
import tornado.web
from colorama import Fore
from impacket.smbserver import SimpleSMBServer
from prompt_toolkit import PromptSession
from prompt_toolkit.auto_suggest import AutoSuggestFromHistory
from prompt_toolkit.completion import NestedCompleter
from prompt_toolkit.formatted_text import HTML
from prompt_toolkit.history import FileHistory
from prompt_toolkit.styles import Style

import transformers


logger.basicConfig(
    format="%(asctime)s.%(msecs)03d %(levelname)s: %(message)s",
    level=logger.INFO,
    datefmt="%H:%M:%S",
)

CONFIG_DIR = Path("./configs/")

PLACEHOLDER_L = "<<"
PLACEHOLDER_R = ">>"
PLACEHOLDER_REGEX = re.compile(rf"{PLACEHOLDER_L}[A-Z]+{PLACEHOLDER_R}")
PLACEHOLDER_SHELL = f"{PLACEHOLDER_L}SHELL{PLACEHOLDER_R}"
PLACEHOLDER_URL = f"{PLACEHOLDER_L}URL{PLACEHOLDER_R}"
PLACEHOLDER_SMB = f"{PLACEHOLDER_L}SMB{PLACEHOLDER_R}"
PLACEHOLDER_SHELLBIN = f"{PLACEHOLDER_L}SHELLBIN{PLACEHOLDER_R}"

IP_REGEX = re.compile(
    r"^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])$"
)


class PayloadManagerConfig:
    def __init__(self):
        self.cvars = {}
        self.stagers = []
        self.shells = []
        self.launchers = []
        self.transformers = {}
        self.stager_folder = Path("./stagers/")
        self.serve_folder = None


class PayloadManager:
    def __new__(cls):
        if not hasattr(cls, "instance"):
            cls.instance = super(PayloadManager, cls).__new__(cls)
            cls.instance.cfg = PayloadManagerConfig()
        return cls.instance

    @property
    def shell_count(self) -> int:
        return len(self.cfg.shells)

    @property
    def launcher_count(self) -> int:
        return len(self.cfg.launchers)

    @property
    def stager_count(self) -> int:
        return len(self.cfg.stagers)

    @property
    def transformer_count(self) -> int:
        return len(self.cfg.transformers)

    def transformer_register(self, cls, enabled=False):
        self.cfg.transformers[cls.__name__] = {"transformer": cls(), "enabled": enabled}

    def get_cvar(self, name: str):
        name = name.upper()
        return self.cfg.cvars[name] if name in self.cfg.cvars else None

    def set_cvar(self, name: str, value):
        self.cfg.cvars[name.upper()] = value

    def load_stagers(self, folder):
        self.cfg.stager_folder = folder
        self.cfg.stagers = []

        for stager in [
            self.stager_process_path(x.relative_to(folder))
            for x in get_all_files(folder)
        ]:
            if self.stager_validate(stager):
                self.cfg.stagers.append(stager)
            else:
                logger.warning(f'Invalid stager "{stager}"')

    def stager_process_path(self, stager_path: Path):
        return str(stager_path).replace("\\", "/").replace("//", "/")

    def stager_validate(self, stager: str) -> bool:
        return self.stager_get_path(stager) is not None

    def stager_exists(self, stager: str) -> bool:
        if stager.startswith("/"):
            stager = stager[1:]
        return stager.lower() in self.cfg.stagers

    def stager_get_path(self, stager: str) -> Path or None:
        if stager.startswith("/"):
            stager = stager[1:]

        p = Path(self.cfg.stager_folder, stager)
        return p if p.exists() else None

    def stager_get_content(self, stager: str) -> str or None:
        stager_path = self.stager_get_path(stager)

        if stager_path:
            with open(stager_path) as stager_file:
                return stager_file.read()

        return None

    def load_shells(self, shells_json):
        self.cfg.shells = json.loads(shells_json)

    def shell_exists(self, shell: str) -> bool:
        return (shell.lower() in self.cfg.shells) if shell else False

    def shell_get_payload(self, shell: str) -> str or None:
        if self.shell_exists(shell):
            return self.cfg.shells[shell]["payload"]
        return None

    def tranformer_switch(self, transformer, status=None):
        if transformer in self.cfg.transformers:
            if status is None:
                self.cfg.transformers[transformer][
                    "enabled"
                ] = not self.cfg.transformers[transformer]["enabled"]
            else:
                self.cfg.transformers[transformer]["enabled"] = status

            if self.cfg.transformers[transformer]["enabled"]:
                logger.info(f"{transformer} {Fore.LIGHTGREEN_EX}enabled{Fore.RESET}")
            else:
                logger.info(f"{transformer} {Fore.LIGHTRED_EX}disabled{Fore.RESET}")
        else:
            logger.warning(f'Tranformer named "{transformer}" does not exist')

    def get_cvars_str(self, s: str):
        for cvar in PLACEHOLDER_REGEX.findall(s):
            yield cvar.replace(PLACEHOLDER_L, "").replace(PLACEHOLDER_R, "").upper()

    def get_cvars_shell(self, shell: str):
        shell_payload = self.shell_get_payload(shell)

        if shell_payload:
            for cvar in self.get_cvars_str(shell_payload):
                yield cvar

    def get_cvars(self, stager: str, shell: str = None):
        stager_path = self.stager_get_path(stager)

        if stager_path:
            with open(self.stager_get_path(stager)) as stager_file:
                for cvar in self.get_cvars_str(stager_file.read()):
                    yield cvar

            for cvar in self.get_cvars_shell(shell):
                yield cvar

    def insert_cvar(self, cvar, payload):
        val = self.get_cvar(cvar)

        if val:
            if not isinstance(val, str):
                val = str(val)

            logger.debug(f'CVAR {cvar} -> "{val}"')
            payload = payload.replace(f"{PLACEHOLDER_L}{cvar}{PLACEHOLDER_R}", val)
        else:
            logger.warning(f'Missing CVAR for shell: "{cvar}"')

        return payload

    def build_payload(self, stager: str, user_agent: str = None) -> str or None:
        shell = ""
        stager_path = self.stager_get_path(stager)

        if stager_path:
            stager_content = self.stager_get_content(stager)

            # insert shell and apply transformers
            shell_inserted = False

            if PLACEHOLDER_SHELL in stager_content:
                shell = self.get_cvar("SHELL")
                shell_payload = self.shell_get_payload(shell)

                if not shell_payload:
                    logger.warning("Stager requested a shell but none was given!")

                    try:
                        possible_os = user_agent.split("(")[1].split(" ")[0].lower()
                        logger.warning(
                            f"OS detected by user-agent: {Fore.LIGHTYELLOW_EX}{possible_os}{Fore.RESET}"
                        )

                        # try to auto select a suiteable shell
                        if possible_os == "windows":
                            shell = "powershell_simple"
                        elif possible_os == "linux":
                            shell = "bash_simple"
                        else:
                            shell = ""

                        if not shell == "":
                            shell_payload = self.shell_get_payload(shell)

                            if shell_payload:
                                logger.warning(
                                    f"Auto-selected shell: {Fore.LIGHTYELLOW_EX}{shell}{Fore.RESET}"
                                )
                            else:
                                logger.warning("No suiteable shell found")

                    except:
                        logger.warning("Failed to auto-select a shell by user-agent")

                if shell_payload:
                    # insert all the shell cvars, because they might become unreadable during transformation
                    for cvar in self.get_cvars_str(shell_payload):
                        shell_payload = self.insert_cvar(cvar, shell_payload)

                    # apply the transformers on shell
                    for transformer in self.cfg.transformers.keys():
                        t = self.cfg.transformers[transformer]

                        if t["enabled"]:
                            tr = t["transformer"]
                            stager_content = tr.trim_chars(
                                stager_content, PLACEHOLDER_SHELL
                            )
                            shell_payload = tr.transform(shell_payload)

                    logger.debug(f"SHELL -> {shell}")
                    stager_content = stager_content.replace(
                        PLACEHOLDER_SHELL, shell_payload
                    )
                    shell_inserted = True

            # insert all the remaining cvars
            for cvar in self.get_cvars(stager, shell):
                if cvar == "SHELL" and shell_inserted:
                    continue

                stager_content = self.insert_cvar(cvar, stager_content)

            return stager_content
        return None

    def load_launchers(self, launchers_json):
        self.cfg.launchers = json.loads(launchers_json)

    def launcher_exists(self, launcher: str) -> bool:
        return (launcher.lower() in self.cfg.launchers) if launcher else False

    def launcher_get_payload(self, launcher: str) -> str or None:
        if self.launcher_exists(launcher):
            return self.cfg.launchers[launcher]["payload"]
        return None

    def launcher_generate(self, launcher, stager, smb_share):
        payload = self.launcher_get_payload(launcher)

        if payload:
            lhost = pm.get_cvar("LHOST")
            payload = payload.replace(PLACEHOLDER_SHELLBIN, self.get_cvar("SHELLBIN"))

            if PLACEHOLDER_URL in payload:
                url = f"http://{lhost}/{stager}"
                return payload.replace(PLACEHOLDER_URL, url)
            elif PLACEHOLDER_SMB in payload:
                # TODO: handle custom samba serving, this does not work at the moment
                smb = f"\\\\{lhost}\\{smb_share}\\{stager}"
                return payload.replace(PLACEHOLDER_SMB, smb)
            else:
                logger.warning(
                    "Launcher contains no valid placeholder (<<URL> or <<SMB>>)"
                )
        else:
            logger.warning(f'Launcher named "{launcher}" does not exist')

        return None


class PssHttpHandler(tornado.web.RequestHandler):
    def get(self):
        pm = PayloadManager()
        p = pm.build_payload(
            self.request.uri, self.request.headers.get("User-Agent", None)
        )

        if p:
            self.set_status(200)
            self.finish(p)

        elif pm.cfg.serve_folder:
            filepath = self.request.uri

            if filepath.startswith("/"):
                filepath = filepath[1:]

            filepath = Path(pm.cfg.serve_folder, filepath)

            if filepath.exists() and filepath.is_file():
                self.set_status(200)

                try:
                    self.set_header("Content-Type", mimetypes.guess_type(filepath)[0])
                except:
                    self.set_header("Content-Type", "application/octet-stream")

                self.set_header(
                    "Content-Disposition", f"attachment; filename={filepath.name}"
                )

                with open(filepath, "rb") as f:
                    self.write(f.read())

                self.finish()
            else:
                self.set_status(404)
                self.finish("404 File Not Found")
        else:
            self.set_status(404)
            self.finish("404 Not Found")


class PssSmbServer(SimpleSMBServer):
    def __init__(self, listenAddress="0.0.0.0", listenPort=445):
        SimpleSMBServer.__init__(self, listenAddress, listenPort)


def get_all_files(path: str or Path):
    if not isinstance(path, Path):
        path = Path(path)

    if path.exists():
        for currentpath, _, files in os.walk(path):
            for file in files:
                yield Path(currentpath, file)


def change_serve_folder(folder: Path, smb_server: PssSmbServer):
    if folder.exists():
        logger.info(
            f'Serving folder changed to "{Fore.LIGHTYELLOW_EX}{folder.absolute()}{Fore.RESET}"'
        )
        pm.cfg.serve_folder = folder

        if smb_server:
            for share in smb_server._SimpleSMBServer__smbConfig.sections():
                if share not in ["global", "IPC$"]:
                    try:
                        smb_server.removeShare(share)
                        logger.info(
                            f'Removed share "{Fore.LIGHTYELLOW_EX}{share}{Fore.RESET}"'
                        )
                    except:
                        logger.warning(
                            f'Failed to remove share "{Fore.LIGHTRED_EX}{share}{Fore.RESET}"'
                        )

            share_name = folder.name.upper()
            share_folder = str(folder.absolute())
            smb_server.addShare(share_name, share_folder)
            smb_server.default_share = share_name
            logger.info(
                f'Added share "{Fore.LIGHTYELLOW_EX}{share_name}{Fore.RESET}":"{Fore.LIGHTYELLOW_EX}{share_folder}{Fore.RESET}"'
            )
    else:
        logger.warning(
            f'Folder "{Fore.LIGHTYELLOW_EX}{folder.absolute()}{Fore.RESET}" does not exist'
        )


def change_cvar(pm, cvar, val):
    if cvar == "LHOST" and not IP_REGEX.search(val):
        logger.info(f'"{val}" is no valid IPv4, treating it as a NIC')

        try:
            ip = ni.ifaddresses(val)[ni.AF_INET][0]["addr"]
            logger.info(f'NIC "{val}" has IPv4 "{Fore.LIGHTYELLOW_EX}{ip}{Fore.RESET}"')
            val = ip
        except:
            logger.warning(
                f'Failed to lookup IPv4 for NIC "{Fore.LIGHTYELLOW_EX}{val}{Fore.RESET}"'
            )

    logger.info(f'{cvar} set to "{Fore.LIGHTYELLOW_EX}{val}{Fore.RESET}"')
    pm.set_cvar(cvar, val)


# runs the tornado server on a thread sot he cli doesn't blocks it
def start_http_server(address: str, port: int):
    address_port = f"{address}:{port}"
    logger.info(
        f"Starting HTTP server on {Fore.LIGHTYELLOW_EX}{address_port}{Fore.RESET}"
    )

    ioloop = tornado.ioloop.IOLoop()
    app = tornado.web.Application([(r".*", PssHttpHandler)])
    app.listen(port, address=address)
    ioloop.start()


def start_smb_server(smb_server: PssSmbServer):
    smb_server.start()


def validate_cmd_len(cmd_arr, expected_len, fail_msg=None):
    if len(cmd_arr) >= expected_len:
        return True
    elif fail_msg:
        logger.warning(fail_msg)
    return False


def split_cmd_args(arr):
    return arr[0].lower(), arr[1:]


def build_config_path(name: str) -> Path:
    if not CONFIG_DIR.exists():
        os.makedirs(CONFIG_DIR)

    # path may start with a "/", this is intended,
    # beware of file overwriting
    config_path = Path(CONFIG_DIR, name)

    if not config_path.parent.exists():
        os.makedirs(config_path)

    return config_path


def save_config(name, pm):
    config_path = build_config_path(name)
    logger.info(f'Saved config "{Fore.LIGHTYELLOW_EX}{name}{Fore.RESET}"')

    try:
        with open(config_path, "w+") as cfg_file:
            cfg_file.write(json.dumps(PayloadManager().cfg.__dict__))
    except Exception as ex:
        logger.warning(
            f'Failed to save file "{Fore.LIGHTRED_EX}{name}{Fore.RESET}": {ex}'
        )


def load_config(name, pm):
    config_path = build_config_path(name)

    if config_path.exists():
        try:
            with open(config_path, "w+") as cfg_file:
                PayloadManager().cfg = json.loads(cfg_file.read())

            logger.info(f'Loaded config "{Fore.LIGHTYELLOW_EX}{name}{Fore.RESET}"')
        except Exception as ex:
            logger.warning(
                f'Failed to load file "{Fore.LIGHTRED_EX}{name}{Fore.RESET}": {ex}'
            )
    else:
        logger.warning(
            f'Config file "{Fore.LIGHTRED_EX}{name}{Fore.RESET}" does not exist'
        )


def try_copy_to_clipboard(s: str):
    try:
        pyperclip.copy(s)
    except Exception as ex:
        logger.error(f"Failed to copy to clipboard: {str(ex)}")


def print_toolbar():
    pm = PayloadManager()
    bottom_str = (
        'SHELL: <style bg="ansiyellow">' + str(pm.get_cvar("SHELL")) + "</style>"
    )
    bottom_str += (
        ' | SHELLBIN: <style bg="ansiyellow">'
        + str(pm.get_cvar("SHELLBIN"))
        + "</style>"
    )
    bottom_str += (
        ' | LHOST: <style bg="ansiyellow">' + str(pm.get_cvar("LHOST")) + "</style>"
    )
    bottom_str += (
        ' | LPORT: <style bg="ansiyellow">' + str(pm.get_cvar("LPORT")) + "</style>"
    )

    if pm.cfg.serve_folder:
        bottom_str += f' | Serving: "<style bg="ansiyellow">{pm.cfg.serve_folder.absolute()}</style>"'

    return HTML(bottom_str)


def print_cmd_unknown(cmd):
    if cmd and len(cmd) > 0:
        logger.warning('Unknown command, type "?" or "help"')


def print_help():
    print(f">> {Fore.LIGHTYELLOW_EX}Basic{Fore.RESET}")
    print("- exit                  : Shutdown server and exit.")
    print(
        "- save {NAME}           : Save current options and shell selection. No name to save as default."
    )
    print(
        "- load {NAME}           : Load saved options and shell selection. No name to load default."
    )
    print("- set {NAME} {VALUE} (s): Set the options value.")
    print("- serve {VALUE}      (x): Set the serving folder.")
    print("- http (copy)           : Print/copy the http server address.")
    print("- smb (copy)            : Print/copy the smb server address.")
    print("- pty (copy)            : Generate/copy python pty shell upgrade command.")
    print("- ncl (copy)            : Generate/copy netcat listener command.")
    print(
        "- msfl (copy)           : Generate/copy metasploit multi/handler listener command."
    )

    print(f"\n>> {Fore.LIGHTYELLOW_EX}Shells{Fore.RESET} (sh, shells)")
    print("- list          (l): List all loaded shells.")
    print("- select {NAME} (s): Select a shell payload.")
    print("- options       (o): Show options for the selected shell.")

    print(f"\n>> {Fore.LIGHTYELLOW_EX}Launchers{Fore.RESET} (l, launchers)")
    print("- generate {LAUNCHER} (copy) : Generate/copy a launcher command.")
    print("- list                (l)    : List all loaded launchers.")

    print(f"\n>> {Fore.LIGHTYELLOW_EX}Stagers{Fore.RESET} (st, stagers)")
    print("- list         (l): List all loaded stagers.")
    print("- print {NAME} (p): Print stager.")
    print("- build {NAME} (b): Print stager with shell.")

    print(f"\n>> {Fore.LIGHTYELLOW_EX}Transformers{Fore.RESET} (t, transformers)")
    print("- list           (l): List all loaded transformers.")
    print("- disableall     (x): Disable all transformers.")
    print("- enable {NAME}  (e): Enable a transformer.")
    print("- disable {NAME} (d): Disable a transformer.")


if __name__ == "__main__":
    colorama.init()

    parser = argparse.ArgumentParser()
    parser.add_argument(
        "--http-host",
        default="0.0.0.0",
        dest="http_host",
        help="Listen address for the HTTP server",
        type=str,
    )
    parser.add_argument(
        "--http-port",
        default="80",
        dest="http_port",
        help="Listen port for the HTTP server",
        type=int,
    )
    parser.add_argument(
        "--smb-host",
        default="0.0.0.0",
        dest="smb_host",
        help="Listen address for the SMB server",
        type=str,
    )
    parser.add_argument(
        "--smb-port",
        default="445",
        dest="smb_port",
        help="Listen port for the SMB server",
        type=int,
    )
    parser.add_argument(
        "-S",
        "--serve",
        default=None,
        dest="serve_folder",
        help="Serve folder for the HTTP server",
        type=str,
    )
    parser.add_argument(
        "--shells-file",
        default="./shells.json",
        dest="shells_file",
        help="JSON file containing shells",
        type=str,
    )
    parser.add_argument(
        "--launchers-file",
        default="./launchers.json",
        dest="launchers_file",
        help="JSON file containing launchers",
        type=str,
    )
    parser.add_argument(
        "--stagers-folder",
        default="./stagers/",
        dest="stagers_folder",
        help="Folder containing stager files",
        type=str,
    )
    parser.add_argument(
        "--lhost", default="", dest="lhost", help="Default LHOST value", type=str
    )
    parser.add_argument(
        "--lport", default="4711", dest="lport", help="Default LPORT value", type=str
    )
    parser.add_argument(
        "--shellbin",
        default="/bin/bash",
        dest="shellbin",
        help="Default shell binary to use",
        type=str,
    )
    parser.add_argument(
        "--no-smb",
        default=False,
        dest="no_smb",
        help="Disable SMB server",
        action="store_true",
    )
    parser.add_argument(
        "--no-smb2",
        default=False,
        dest="no_smb2",
        help="Disable SMB2 support",
        action="store_true",
    )
    parser.add_argument(
        "--no-history",
        default=False,
        dest="no_history",
        help='Disable history saving in file "~/.psshistory"',
        action="store_true",
    )
    args = parser.parse_args()

    print(f">> {Fore.LIGHTYELLOW_EX}Pentest Server Suite{Fore.RESET}")
    print("   https://github.com/Jnnshschl/PentestServerSuite\n")

    pm = PayloadManager()

    # load all shells
    if Path(args.shells_file).exists():
        with open(args.shells_file) as shells_file:
            pm.load_shells(shells_file.read())

        logger.info(f"Loaded {Fore.LIGHTYELLOW_EX}{pm.shell_count}{Fore.RESET} Shells")
    else:
        logger.error(f'Shells file missing: "{args.shells_file}"')

    shells_set = {}

    for shell in pm.cfg.shells:
        shells_set[shell] = None

    # load all stagers
    if Path(args.stagers_folder).exists():
        pm.load_stagers(args.stagers_folder)
        logger.info(
            f"Loaded {Fore.LIGHTYELLOW_EX}{pm.stager_count}{Fore.RESET} Stagers"
        )
    else:
        logger.error(f'Stagers folder missing: "{args.stagers_folder}"')

    stagers_set = {}

    for stager in pm.cfg.stagers:
        stagers_set[stager] = None

    # load all launchers
    if Path(args.launchers_file).exists():
        with open(args.launchers_file) as launchers_file:
            pm.load_launchers(launchers_file.read())

        logger.info(
            f"Loaded {Fore.LIGHTYELLOW_EX}{pm.launcher_count}{Fore.RESET} Launchers"
        )
    else:
        logger.error(f'Launchers file missing: "{args.launchers_file}"')

    launchers_set = {}

    for launcher in pm.cfg.launchers:
        launchers_set[launcher] = stagers_set

    # load all tranformers
    default_transformers = inspect.getmembers(
        transformers,
        lambda o: inspect.isclass(o) and issubclass(o, transformers.ITransformer),
    )

    transformers_set = {}

    for transformer in default_transformers:
        if transformer[0] != "ITransformer":
            pm.transformer_register(transformer[1])
            transformers_set[transformer[0]] = None

    logger.info(
        f"Loaded {Fore.LIGHTYELLOW_EX}{pm.transformer_count}{Fore.RESET} Tranformers"
    )

    # set initial cvar values
    if args.lhost and len(args.lhost) > 0:
        change_cvar(pm, "LHOST", args.lhost)

    if args.lport:
        change_cvar(pm, "LPORT", args.lport)

    if args.shellbin:
        change_cvar(pm, "SHELLBIN", args.shellbin)

    # start tornado webserver in background
    tornado_thread = threading.Thread(
        target=start_http_server, args=[args.http_host, args.http_port], daemon=True
    )
    tornado_thread.start()

    # start samba server in background
    if not args.no_smb:
        smb_server = PssSmbServer(args.smb_host, int(args.smb_port))
        smb_server.setSMB2Support(not args.no_smb2)
        smb_server.default_share = "NONE"

        smb_thread = threading.Thread(
            target=start_smb_server, args=[smb_server], daemon=True
        )
        smb_thread.start()
    else:
        smb_server = None

    # change serving folder if supplied
    if args.serve_folder:
        change_serve_folder(Path(args.serve_folder), smb_server)

    # setup prompt
    prompt_file = Path(os.path.expanduser("~"), ".psshistory")

    shells_dict = {
        "list": None,
        "set": shells_set,
        "select": shells_set,
        "options": None,
    }

    launchers_dict = {
        "list": None,
        "generate": launchers_set,
    }

    stagers_dict = {
        "list": None,
        "print": stagers_set,
        "build": stagers_set,
    }

    transformers_dict = {
        "list": None,
        "disableall": None,
        "enable": transformers_set,
        "disable": transformers_set,
    }

    copy_dict = {"copy": None}

    cli_session = PromptSession(
        history=None if args.no_history else FileHistory(prompt_file),
        auto_suggest=AutoSuggestFromHistory(),
        bottom_toolbar=print_toolbar,
        style=Style.from_dict(
            {"pss": "ansibrightyellow", "bottom-toolbar": "#303030 bg:#dddddd"}
        ),
        completer=NestedCompleter.from_nested_dict(
            {
                "exit": None,
                "save": None,
                "load": None,
                "set": {
                    "LHOST": None,
                    "LPORT": None,
                },
                "serve": None,
                "http": copy_dict,
                "smb": copy_dict,
                "ncl": copy_dict,
                "msfl": copy_dict,
                "pty": copy_dict,
                "sh": shells_dict,
                "shell": shells_dict,
                "shells": shells_dict,
                "l": launchers_dict,
                "launcher": launchers_dict,
                "launchers": launchers_dict,
                "st": stagers_dict,
                "stager": stagers_dict,
                "stagers": stagers_dict,
                "t": transformers_dict,
                "transformer": transformers_dict,
                "transformers": transformers_dict,
            }
        ),
        message=[
            ("class:pss", "pss"),
            ("", "> "),
        ],
    )

    # enter cmd loop
    while 1:
        input_arr = cli_session.prompt().strip().split(" ")
        cmd, args = split_cmd_args(input_arr)

        if cmd == "?" or cmd == "help":
            print_help()

        elif cmd == "exit":
            break

        elif cmd == "save":
            save_config(args[0] if len(args) > 0 else "default", pm)

        elif cmd == "load":
            load_config(args[0] if len(args) > 0 else "default", pm)

        elif cmd == "s" or cmd == "set":
            if validate_cmd_len(
                input_arr, 2, 'Missing arguments: "cvar name", "value"'
            ):
                if validate_cmd_len(input_arr, 3, 'Missing arguments: "value"'):
                    change_cvar(pm, input_arr[1].upper(), " ".join(input_arr[2:]))

        elif cmd == "x" or cmd == "serve":
            if validate_cmd_len(input_arr, 2, 'Missing arguments: "folder"'):
                change_serve_folder(Path(" ".join(input_arr[1:])), smb_server)

        elif cmd == "http":
            lhost = pm.get_cvar("LHOST")
            http_host = f"http://{lhost}/"
            print(http_host)

            if len(args) > 0 and (args[0].lower() == "c" or args[0].lower() == "copy"):
                try_copy_to_clipboard(http_host)

        elif cmd == "smb":
            lhost = pm.get_cvar("LHOST")
            smb_host = f"\\\\{lhost}\\{smb_server.default_share}\\"
            print(smb_host)

            if len(args) > 0 and (args[0].lower() == "c" or args[0].lower() == "copy"):
                try_copy_to_clipboard(smb_host)

        elif cmd == "l" or cmd == "launcher" or cmd == "launchers":
            # LAUNCHER sub-commands
            if validate_cmd_len(input_arr, 2, 'Missing arguments: "sub-command"'):
                sub_cmd, sub_args = split_cmd_args(args)

                if sub_cmd == "l" or sub_cmd == "list":
                    for launcher in pm.cfg.launchers:
                        print(launcher)

                elif sub_cmd == "g" or sub_cmd == "generate":
                    if validate_cmd_len(input_arr, 3, 'Missing arguments: "launcher"'):
                        launcher, sub_sub_args = split_cmd_args(sub_args)

                        if validate_cmd_len(
                            input_arr,
                            4,
                            f'No stager sepcified, using "{Fore.LIGHTYELLOW_EX}pss/direct{Fore.RESET}" as default...',
                        ):
                            stager, sub_sub_args = split_cmd_args(sub_sub_args)
                        else:
                            stager = "pss/direct"

                        launcher_cmd = pm.launcher_generate(
                            launcher, stager, smb_server.default_share
                        )
                        print(launcher_cmd)

                        if len(sub_sub_args) > 0 and (
                            sub_sub_args[0].lower() == "c"
                            or sub_sub_args[0].lower() == "copy"
                        ):
                            try_copy_to_clipboard(launcher_cmd)

                else:
                    print_cmd_unknown(sub_cmd)

        elif cmd == "ncl":
            lport = pm.get_cvar("LPORT")
            x_cmd = f"nc -lvpn {lport}"
            print(x_cmd)

            if len(args) > 0 and (args[0].lower() == "c" or args[0].lower() == "copy"):
                try_copy_to_clipboard(x_cmd)

        elif cmd == "msfl":
            lhost = pm.get_cvar("LHOST")
            lport = pm.get_cvar("LPORT")
            x_cmd = f'msfconsole -q -x "use multi/handler; set LHOST {lhost}; set LPORT {lport}; run"'
            print(x_cmd)

            if len(args) > 0 and (args[0].lower() == "c" or args[0].lower() == "copy"):
                try_copy_to_clipboard(x_cmd)

        elif cmd == "pty":
            shellbin = pm.get_cvar("SHELLBIN")
            x_cmd = f"python -c 'import pty; pty.spawn(\"{shellbin}\")'"
            print(x_cmd)

            if len(args) > 0 and (args[0].lower() == "c" or args[0].lower() == "copy"):
                try_copy_to_clipboard(x_cmd)

        elif cmd == "sh" or cmd == "shell" or cmd == "shells":
            # SHELL sub-commands
            if validate_cmd_len(input_arr, 2, 'Missing arguments: "sub-command"'):
                sub_cmd, sub_args = split_cmd_args(args)

                if sub_cmd == "l" or sub_cmd == "list":
                    for shell in pm.cfg.shells:
                        print(shell)

                elif sub_cmd == "s" or sub_cmd == "set" or sub_cmd == "select":
                    shell = sub_args[0].lower()

                    if pm.shell_exists(shell):
                        logger.info(
                            f'Shell set to "{Fore.LIGHTYELLOW_EX}{shell}{Fore.RESET}"'
                        )
                        pm.set_cvar("SHELL", shell)
                    else:
                        logger.warning(
                            f'No shell found with name "{Fore.LIGHTRED_EX}{shell}{Fore.RESET}". If you want to directly inject something, set the SHELL option manually using "set SHELL ..."'
                        )

                elif sub_cmd == "o" or sub_cmd == "options":
                    shell = pm.get_cvar("SHELL")
                    logger.info(
                        f'Selected shell "{Fore.LIGHTYELLOW_EX}{shell}{Fore.RESET}"'
                    )

                    if shell:
                        for cvar in pm.get_cvars_shell(shell):
                            val = pm.get_cvar(cvar)

                            if val:
                                logger.info(
                                    f'{cvar} = "{Fore.LIGHTYELLOW_EX}{val}{Fore.RESET}"'
                                )
                            else:
                                logger.info(
                                    f"{cvar} = {Fore.LIGHTRED_EX}Not set{Fore.RESET}"
                                )

                else:
                    print_cmd_unknown(sub_cmd)

        elif cmd == "st" or cmd == "stager" or cmd == "stagers":
            # STAGER sub-commands
            if validate_cmd_len(input_arr, 2, 'Missing arguments: "sub-command"'):
                sub_cmd, sub_args = split_cmd_args(args)

                if sub_cmd == "l" or sub_cmd == "list":
                    for stager in pm.cfg.stagers:
                        print(stager)

                elif sub_cmd == "p" or sub_cmd == "print":
                    print(pm.stager_get_content(sub_args[0].lower()))

                elif sub_cmd == "b" or sub_cmd == "build":
                    print(pm.build_payload(sub_args[0].lower()))

                else:
                    print_cmd_unknown(sub_cmd)

        elif cmd == "t" or cmd == "transformer" or cmd == "transformers":
            # TRANFORMER sub-commands
            if validate_cmd_len(input_arr, 2, 'Missing arguments: "sub-command"'):
                sub_cmd, sub_args = split_cmd_args(args)

                if sub_cmd == "l" or sub_cmd == "list":
                    for transformer in pm.cfg.transformers.keys():
                        is_enabled = pm.cfg.transformers[transformer]["enabled"]
                        color = Fore.LIGHTGREEN_EX if is_enabled else Fore.LIGHTRED_EX
                        print(f"{transformer}: {color}{is_enabled}{Fore.RESET}")

                elif sub_cmd == "x" or sub_cmd == "disableall":
                    for transformer in pm.cfg.transformers.keys():
                        is_enabled = pm.cfg.transformers[transformer]["enabled"]

                        if is_enabled:
                            pm.cfg.transformers[transformer]["enabled"] = False
                            logger.info(
                                f"{transformer} {Fore.LIGHTRED_EX}disabled{Fore.RESET}"
                            )

                elif sub_cmd == "e" or sub_cmd == "+" or sub_cmd == "enable":
                    pm.tranformer_switch(sub_args[0], True)

                elif sub_cmd == "d" or sub_cmd == "-" or sub_cmd == "disable":
                    pm.tranformer_switch(sub_args[0], False)

                elif args[0] in pm.cfg.transformers:
                    pm.tranformer_switch(args[0])

                else:
                    print_cmd_unknown(sub_cmd)

        else:
            print_cmd_unknown(cmd)

    colorama.deinit()
