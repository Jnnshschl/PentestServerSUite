import logging as logger
import os
from inspect import isfunction
from pathlib import Path
from pprint import pprint


class CmdHandler:
    def __init__(self, triggers: list | str = None, sub_handler: list = None, autocompletion=None):
        self.triggers = triggers or (triggers if isinstance(triggers, list) else [triggers])
        self.sub_handler = sub_handler or []
        self.autocompletion = autocompletion

    @staticmethod
    def split(arr, cmd_lower: bool = False):
        if len(arr) > 0:
            return (
                arr[0].lower() if cmd_lower else arr[0],
                arr[1:] or [],
            )
        return ("", [])

    def tree(self):
        if isinstance(self.sub_handler, list) and self.sub_handler:
            tree_dict = {}

            for sub_handler in self.sub_handler:
                if isinstance(sub_handler, CmdHandler):
                    tree_dict[tuple(sub_handler.triggers)] = sub_handler.tree()
                else:
                    tree_dict[tuple(sub_handler.triggers)] = sub_handler.autocompletion

            return tree_dict
        return self.autocompletion

    def handle(self, s: list) -> bool:
        cmd, args = CmdHandler.split(s, True)

        if isfunction(self.sub_handler):
            return self.sub_handler(s)
        elif isinstance(self.sub_handler, CmdValidator):
            return self.sub_handler.validate(s)
        else:
            for handler in self.sub_handler:
                for trigger in handler.triggers:
                    if cmd == trigger:
                        return handler.handle(args)

        logger.warning("Unknown command, available commands:")
        pprint([x.triggers for x in self.sub_handler])
        return False

    def add(self, triggers, sub_handler=None, autocompletion=None):
        s = CmdHandler(triggers, sub_handler, autocompletion)
        self.sub_handler.append(s)
        return s

    def add_handler(self, handler):
        self.sub_handler.append(handler)
        return self

    def __str__(self) -> str:
        return str(self.tree())


class CmdValidator:
    def __init__(self, fn: callable):
        self.fn = fn

    def validate(self, args):
        pass


class CmdLenValidator(CmdValidator):
    def __init__(self, fn: callable, min_len: int, missing_arg_names: list):
        CmdValidator.__init__(self, fn)
        self.min_len = min_len

        if missing_arg_names is not None:
            assert min_len == len(missing_arg_names)

        self.missing_arg_names = missing_arg_names

    def validate(self, args):
        args_len = len(args)

        if args_len < self.min_len:
            fail_msg = "Missing arguments: "

            for txt in self.missing_arg_names[args_len:]:
                fail_msg += f'"{txt}", '

            logger.error(fail_msg.removesuffix(", "))
            return None

        return self.fn(args)


def ensure_folder(folder: str | Path):
    try:
        if not isinstance(folder, Path):
            folder = Path(folder)

        if not folder.exists():
            os.makedirs(folder)

    except:
        return False
    return folder.exists()
