import json
import logging as logger
import os
import subprocess
from multiprocessing import Process
from pathlib import Path
from tempfile import NamedTemporaryFile

from colorama import Fore
from lmdbm import Lmdb

from pssutil.cmdutils import CmdLenValidator

TAG = f"[{Fore.LIGHTCYAN_EX}PassCrack{Fore.RESET}]"
PASSCRACK_FOLDER = Path("./conf/passcrack.db")

HASHCAT_MODE_DICT = {
    "md5": 0,
    "sha1": 100,
    "md5crypt": 500,
    "md4": 900,
    "ntlm": 1000,
    "sha2-224": 1300,
    "sha2-256": 1400,
    "apache-md5": 1600,
    "sha2-512": 1700,
    "sha512crypt": 1800,
    "lm": 3000,
    "bcrypt": 3200,
    "netntlmv1": 5500,
    "netntmlv2": 5600,
    "krb5": 7500,
    "krb5-asrep": 18200,
    "krb5-e17-preauth": 19800,
    "krb5-e18-preauth": 19900,
}


def add_cmd(pm, cmd):
    PassCrackDB()
    passcrack_handler = cmd.add(["passcrack"])

    crack_handler = passcrack_handler.add(["crack"])
    hash_autocompletion = {}

    for k in HASHCAT_MODE_DICT.keys():
        hash_autocompletion[k] = None

    crack_handler.add(
        ["hashcat"], CmdLenValidator(hash_crack, 2, ["algorithm", "hash or hash|hash2|hash3", "wordlist", "args"]), hash_autocompletion
    )

    passcrack_handler.add(["autocrack"], CmdLenValidator(hash_autocrack, 1, ["algorithm (optional)", "hash"]), hash_autocompletion)
    passcrack_handler.add(["lookup"], CmdLenValidator(hash_lookup, 1, ["algorithm", "hash"]), hash_autocompletion)
    passcrack_handler.add(["add"], CmdLenValidator(hash_add, 3, ["algorithm", "hash", "cleaxtext"]), hash_autocompletion)
    passcrack_handler.add(["delete"], CmdLenValidator(hash_delete, 2, ["algorithm", "hash"]), hash_autocompletion)


def hash_add(args):
    PassCrackDB().add(args[1], args[0], args[2])


def hash_delete(args):
    PassCrackDB().delete(args[1], args[0])


def hash_lookup(args):
    hash_value = args[1] if len(args) > 1 else args[0]
    algorithm = args[0] if len(args) > 1 else None

    if algorithm is None:
        all_values = PassCrackDB().try_get_all(hash_value)

        if all_values:
            for alg, val in all_values.items():
                logger.info(f"{TAG} [{alg}]: {Fore.LIGHTYELLOW_EX}{hash_value}{Fore.RESET} -> {Fore.LIGHTGREEN_EX}{val}{Fore.RESET}")
        else:
            logger.info(f"{TAG} {Fore.LIGHTRED_EX}No matching password found...{Fore.RESET}")

    else:
        val = PassCrackDB().try_get(hash_value, algorithm)

        if val is not None:
            logger.info(f"{TAG} [{algorithm}]: {Fore.LIGHTYELLOW_EX}{hash_value}{Fore.RESET} -> {Fore.LIGHTGREEN_EX}{val}{Fore.RESET}")
        else:
            logger.info(f"{TAG} {Fore.LIGHTRED_EX}No matching password found...{Fore.RESET}")


def hash_crack(args):
    hc_mode = type_to_hc_mode(args[0])

    if hc_mode is None:
        logger.info(f"{TAG} {Fore.LIGHTRED_EX}No matching hashcat mode found...{Fore.RESET}")
        return

    wordlist = args[2] if len(args) > 2 else try_get_wordlist()
    PassCrackJob(args[0], hc_mode, args[1], wordlist, args[3:])


def hash_autocrack(args):
    hash_value = args[1] if len(args) > 1 else args[0]
    algorithm = args[0] if len(args) > 1 else None

    if algorithm is None:
        all_values = PassCrackDB().try_get_all(hash_value)

        if all_values:
            for alg, val in all_values.items():
                logger.info(f"{TAG} [{alg}]: {Fore.LIGHTYELLOW_EX}{hash_value}{Fore.RESET} -> {Fore.LIGHTGREEN_EX}{val}{Fore.RESET}")
        else:
            # TODO: detect hash format and try to crack it
            pass
    else:
        val = PassCrackDB().try_get(hash_value, algorithm)

        if val is not None:
            logger.info(f"{TAG} [{algorithm}]: {Fore.LIGHTYELLOW_EX}{hash_value}{Fore.RESET} -> {Fore.LIGHTGREEN_EX}{val}{Fore.RESET}")
        else:
            hc_mode = type_to_hc_mode(algorithm)

            if hc_mode is not None:
                wordlist = args[2] if len(args) > 2 else try_get_wordlist()
                PassCrackJob(args[0], hc_mode, hash_value, wordlist, args[3:])
            else:
                logger.info(f"{TAG} {Fore.LIGHTRED_EX}No matching hashcat mode found...{Fore.RESET}")


def run_hashcat(hc_mode, passwords, wordlist, args):
    with NamedTemporaryFile("w+") as tmp_file:
        tmp_file.write(passwords.replace("|", os.linesep))
        tmp_file.flush()

        logger.info(
            f"{TAG} Hashcat: Started job '{Fore.LIGHTYELLOW_EX}{tmp_file.name}{Fore.RESET}' using '{Fore.LIGHTYELLOW_EX}{wordlist}{Fore.RESET}', '{Fore.LIGHTYELLOW_EX}{args}{Fore.RESET}'"
        )

        with NamedTemporaryFile("w+") as result_file:
            try:
                command = [
                    f"hashcat -O --quiet --status-json --potfile-disable --outfile-format 1,2 -o '{result_file.name}' -m {hc_mode} '{tmp_file.name}' '{wordlist}'"
                ]
                subprocess.run(command, shell=True, capture_output=True, text=True, check=True)
            except subprocess.CalledProcessError as e:
                logger.warning(f"{TAG} Not all hashes may be cracked: {e}")

            for line in result_file.readlines():
                yield line.strip().split(":")


def try_get_wordlist():
    rockyou = Path("/usr/share/wordlists/rockyou.txt")
    return str(rockyou) if rockyou.exists() else None


def type_to_hc_mode(mode):
    return HASHCAT_MODE_DICT.get(mode, None)


class PassCrackJob:
    def __init__(self, algorithm, hc_mode, passwords, wordlist, args):
        self.algorithm = algorithm
        self.hc_mode = hc_mode
        self.passwords = passwords
        self.wordlist = wordlist
        self.args = args
        self.thread = Process(target=self.run, args=(), daemon=True)
        self.thread.start()

    def run(self):
        for h, p in run_hashcat(self.hc_mode, self.passwords, self.wordlist, self.args):
            logger.info(f"{TAG} {Fore.LIGHTYELLOW_EX}{h}{Fore.RESET}: '{Fore.LIGHTGREEN_EX}{p}{Fore.RESET}'")
            PassCrackDB().add(h, self.algorithm, p)


class JsonLmdb(Lmdb):
    def _pre_key(self, value):
        return value.encode("utf-8")

    def _post_key(self, value):
        return value.decode("utf-8")

    def _pre_value(self, value):
        return json.dumps(value).encode("utf-8")

    def _post_value(self, value):
        return json.loads(value.decode("utf-8"))


class PassCrackDB:
    def __new__(cls, *args, **kwds):
        it = cls.__dict__.get("__it__")
        if it is not None:
            return it
        cls.__it__ = it = object.__new__(cls)
        it.init(*args, **kwds)
        return it

    def init(self) -> None:
        if not PASSCRACK_FOLDER.parent.exists():
            os.makedirs(PASSCRACK_FOLDER.parent)

        self.db_path = Path(PASSCRACK_FOLDER)
        logger.info(f'{TAG} Loading DB: "{Fore.LIGHTYELLOW_EX}{self.db_path}{Fore.RESET}"')
        self.db = JsonLmdb.open(str(self.db_path.absolute()), "c")

    def add(self, hash_value, algorithm, cleartext):
        if hash_value in self.db:
            self.db[hash_value][algorithm] = cleartext
        else:
            self.db[hash_value] = {algorithm: cleartext}

    def delete(self, hash_value, algorithm):
        if hash_value in self.db:
            del self.db[hash_value][algorithm]

    def try_get(self, hash_value, algorithm) -> str:
        v = self.try_get_all(hash_value)
        return v[algorithm] if algorithm in v else None

    def try_get_all(self, hash_value) -> str:
        if hash_value in self.db:
            return self.db[hash_value]
        return {}

    def __del__(self):
        self.db.close()
