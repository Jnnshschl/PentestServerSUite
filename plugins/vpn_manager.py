import base64
import logging as logger
import lzma
import subprocess
from multiprocessing import Process
from pathlib import Path

from colorama import Fore

from pssutil.cmdutils import CmdLenValidator
from pssutil.fileutils import load_json, save_json

TAG = f"[{Fore.LIGHTYELLOW_EX}VPN{Fore.RESET}]"
VPN_FILE = Path("./conf/vpn.json")
VPN_THREADS = {}


def add_cmd(pm, cmd):
    global VPN_FILE
    vpn_handler = cmd.add(["vpn"])
    ovpn_handler = vpn_handler.add(["openvpn"])

    cfg_json = load_json(VPN_FILE)
    vpn_autocompletion = {}

    for k in cfg_json.keys():
        vpn_autocompletion[k] = None

    ovpn_handler.add(["connect"], CmdLenValidator(openvpn_connect, 1, ["config name"]), vpn_autocompletion)
    ovpn_handler.add(["disconnect"], CmdLenValidator(openvpn_disconnect, 1, ["config name"]), vpn_autocompletion)

    ovpn_handler.add(["import"], CmdLenValidator(openvpn_import, 2, ["config name", "filepath"]))
    ovpn_handler.add(["delete"], CmdLenValidator(openvpn_delete, 1, ["config name"]))


def openvpn_connect(args):
    global VPN_FILE
    global VPN_THREADS
    vpn_thread = VPN_THREADS.get(args[0], None)

    if vpn_thread is None:
        cfg_json = load_json(VPN_FILE)

        if cfg_json is None:
            cfg_json = {}

        config = cfg_json.get(args[0], None)

        if config is not None:
            VPN_THREADS[args[0]] = VpnThread(args[0], config)
        else:
            logger.error(f'{TAG} VPN config named "{Fore.LIGHTYELLOW_EX}{args[0]}{Fore.RESET}" does not exist')
    else:
        logger.error(f'{TAG} VPN "{Fore.LIGHTYELLOW_EX}{args[0]}{Fore.RESET}" is already running...')


def openvpn_disconnect(args):
    global VPN_THREADS
    vpn_thread = VPN_THREADS.get(args[0], None)

    if vpn_thread is not None:
        VPN_THREADS[args[0]].thread.kill()
        del VPN_THREADS[args[0]]
    else:
        logger.error(f'{TAG} VPN "{Fore.LIGHTYELLOW_EX}{args[0]}{Fore.RESET}" is not running...')


def openvpn_import(args):
    global VPN_FILE
    filepath = Path(args[1])

    if filepath.exists():
        comp_data = compress_file_and_encode(filepath).decode()
        cfg_json = load_json(VPN_FILE)

        if cfg_json is None:
            cfg_json = {}

        cfg_json[args[0]] = comp_data
        save_json(VPN_FILE, cfg_json)
    else:
        logger.error(f'{TAG} File "{Fore.LIGHTYELLOW_EX}{filepath}{Fore.RESET}" not found...')


def openvpn_delete(args):
    global VPN_FILE
    cfg_json = load_json(VPN_FILE)

    if cfg_json is not None:
        del cfg_json[args[0]]
        save_json(VPN_FILE, cfg_json)


def compress_file_and_encode(input_file_path: bytes) -> bytes:
    with open(input_file_path, "rb") as file:
        return base64.b64encode(lzma.compress(file.read()))


def decode_and_decompress(compressed_data: bytes) -> bytes:
    return lzma.decompress(base64.b64decode(compressed_data))


class VpnThread:
    def __init__(self, name, config):
        self.name = name
        self.config = config
        self.openvpn_process = None
        self.thread = Process(target=self.run, args=(), daemon=True)
        self.thread.start()

    def run(self):
        logger.info(f"{TAG} Starting openvpn: '{Fore.LIGHTYELLOW_EX}{self.name}{Fore.RESET}'")
        self.openvpn_process = subprocess.Popen(["openvpn", "--config", "/dev/stdin"], stdout=subprocess.DEVNULL, stdin=subprocess.PIPE)
        self.openvpn_process.communicate(decode_and_decompress(self.config.encode()))
